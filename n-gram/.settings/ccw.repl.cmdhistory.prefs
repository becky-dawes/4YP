cmdhistory=["(second (vector \#(/ (+ % 1) 1) counts-1-vals))" "(first  \#(/ (+ % 1) 1) counts-1-vals)" "(first  (\#(/ (+ % 1) 1) counts-1-vals))" "(vector  (map \#(/ (+ % 1) 1) counts-1-vals))" "(last(vector  (map \#(/ (+ % 1) 1) counts-1-vals)))" "(last (vector  (map \#(/ (+ % 1) 1) counts-1-vals)))" "counts-1-vals" "(sum (vector  (map \#(/ (+ % 1) 1) counts-1-vals)))" "(sum   (map \#(/ (+ % 1) 1) counts-1-vals))" "(K 1)" "(take 20 (iterate inc 0))" "(take (- 20 2) (iterate inc 2))" "find-optimum-u" "find-optimum-u-memo" "(find-optimum-u-memo)" "find-optimum-u" "(find-optimum-u initial-alpha)" "find-optimum-u" "(find-optimum-u initial-alpha)" "(def u-0 (find-all-u-memo initial-alpha))" "u-0" "(def u-0 (find-all-u-memo initial-alpha))" "(def alpha-1 (alpha-MP-memo u-0))" "(zipmap (vals counts-1) (map \#(+ 1 %) (keys counts-1)))" "(zipmap (keys counts-1) (map \#(+ 1 %) (vals counts-1)))" "(def text [\\"the\\" \\"cat\\" \\"sat\\" \\"on\\" \\"the\\" \\"mat\\"])" "(def words (make-words text))" "(find-optimum-u)" "(find-optimum-u initial-alpha)" "(find-optimum-u)" "(/ 8 3)" "(float (/ 8 3))" "(with-precision 1 (float (/ 8 3)))" "(with-precision 2 (float (/ 8 3)))" "(\= 1 1.000000000001)" "(with-precision 1 (\= 1 1.000000001))" "(with-precision 1 (\= 1 1.1))" "(with-precision 2 (\= 1 1.1))" "(with-precision 10 (\= 1 1.1))" "(with-precision 1 (1.111))" "(with-precision 1 (/ 1.111 1))" "(with-precision 2 (/ 1.111 1))" "(with-precision 3 (/ 1.111 1))" "(with-precision 10 (/ 1.111 1))" "(with-precision 0 (/ 1.111 1))" "(with-precision 1 (/ 1.111M 1))" "(with-precision 10 (/ 1.111M 1))" "(with-precision 100 (/ 1.111M 1))" "(with-precision 2 (/ 1.111M 1))" "(with-precision 3 (/ 1.111M 1))" "(float 1M)" "(find-optimum-u)" "(def opt-u (find-optimum-u-memo))" "(def opt-alpha (alpha-MP-memo opt-u))" "opt-alpha" "(def opt-m (find-all-m-memo opt-alpha opt-u))" "(P \\"one\\" \\"day\\" opt-alpha opt-m)" "counts-1" "(def opt-u (find-optimum-u))" "(def opt-alpha (alpha-MP-memo opt-u))" "(def opt-m (find-all-m-memo opt-alpha opt-u))" "(P \\"once\\" \\"upon\\" opt-alpha opt-m)" "(counts-2 [\\"once\\" \\"upon\\"])" "counts-2" "(counts-2 [\\"once\\" \\"upon\\"])" "(P \\"once\\" \\"upon\\" opt-alpha opt-m)" "(counts-1 \\"upon\\")" "counts-1" "(P \\"once\\" \\"upon\\" opt-alpha opt-m)" "(counts-1 [\\"upon\\"])" "(find-m-i \\"once\\" opt-m)" "(find-m-i [\\"once\\"] opt-m)" "(P \\"once\\" \\"upon\\" opt-alpha opt-m)" "(bigdec 3.0001)" "(with-precision 1 (bigdec 3.0001))" "(with-precision 1 (\= (bigdec 3.0001) (bigdec 3)))" "(with-precision 1 (\= (format %.1f 3.0001) (format %.1f 3)))" "(with-precision 1 (\= (format \\"%.1f\\" 3.0001) (format \\"%.1f\\" 3)))" "(with-precision 1 (\= (format \\"%.2f\\" 3.0001) (format \\"%.2f\\" 3)))" "(defn equal [num1 num2 accuracy]\\n  (letfn [(bignum [num]\\n            (.setScale (BigDecimal. num)\\n                       accuracy\\n                       BigDecimal/ROUND_DOWN))]\\n    (\= 0 (.compareTo (bignum num1) (bignum num2)))))" "(equal 3.0001 3 1)" "(equal 3.0001 3 2)" "(equal 3.0001 3 3)" "(equal 3.0001 3 4)" "(def u-0 (find-optimum-u-memo))" "(def u (find-optimum-u-memo))" "(def alpha (alpha-MP-memo u))" "(def m (find-all-m-memo alpha))" "(def m (find-all-m-memo alpha u))" "(P-memo \\"once\\" \\"upon\\" alpha m)" "(P-memo \\"once\\" \\"the\\" alpha m)" "(def u (find-optimum-u-memo))" "(def alpha (alpha-MP-memo u))" "(def m (find-all-m-memo alpha u))" "(perplexity alpha m)" "(P-memo \\"once\\" \\"the\\" alpha m)" "(f-i-j 0 0)" "(f-i-j 0 1)" "(P \\"once\\" \\"the\\" alpha m)" "(def the-F-i-j (get-count counts-2 [\\"once\\" \\"the\\"]))" "(def the-F-j (get-count counts-1 [\\"the\\"]))" "(f-i-j the-F-i-j the-F-j)" "the-F-j" "words" "the-F-i-j" "(perplexity)" "alpha-optimum" "m-optimum" "counts-1" "words" "counts-1" "u-optimum" "(K alpha-optimum)" "(G \\"into\\")" "(G-i \\"into\\")" "G-i \\"the\\")" "(G-i \\"the\\")" "(G-i \\"a\\")" "(H-i \\"the\\")" "(H-i \\"a\\")" "(V-i \\"a\\")" "(F-w2-given-w1 \\"the\\")" "(V-i \\"the\\" (F-w2-given-w1 \\"the\\"))" "(V-i \\"a\\" (F-w2-given-w1 \\"a\\"))" "(V-i \\"dorothy\\" (F-w2-given-w1 \\"dorothy\\"))" "(vals (F-w2-given-w1 \\"the\\"))" "(sum (vals (F-w2-given-w1 \\"the\\")))" "(sum (vals (F-w2-given-w1 \\"dorothy\\")))" "u-optimum" "(def F-the (f-w2-w1 \\"the\\"))" "(def F-the (F-w2-given-w1 \\"the\\"))" "(def F-dorothy (F-w2-given-w1 \\"dorothy\\"))" "F-the" "(V-i \\"the\\" (vals F-the))" "(V-i \\"dorothy\\" (vals F-dorothy))" "(sum (map \#(if (\= 0 %) 0 1) (vals F-the)))" "(sum (map \#(if (\= 0 %) 0 1) (vals F-dorothy)))" "(count counts-1)" "(map \#(if (\= 0 %) 0 1) (vals F-dorothy))" "(count counts-2)" "(count counts-1)" "(vals F-the)" "u-optimum" "(F-w2-given-w1 \\"the\\")" "(vals (F-w2-given-w1 \\"the\\"))" "(map \#(if (\= 0 %) 0 1)(vals (F-w2-given-w1 \\"the\\")))" "(sum (map \#(if (\= 0 %) 0 1)(vals (F-w2-given-w1 \\"the\\"))))" "(sum (map \#(if (\= 0 %) 0 1)(vals (F-w2-given-w1 \\"dorothy\\"))))" "(V-i (vals (F-w2-given-w1 \\"the\\")))" "(V-i (vals (F-w2-given-w1 \\"dorothy\\")))" "(find-optimum-u)" "(K 1)" "(java.lang.Math/log 1)" "(java.lang.Math/log 2)" "(java.lang.Math/log 0)" "counts-1" "(vals counts-1)" "(java.lang.Math/log -1)" "(java.lang.Math/log 0.1)" "(map \#(Math/log (/ (+ % 20) 20)) (vals counts-1))" "(sum (map \#(Math/log (/ (+ % 20) 20)) (vals counts-1)))" "(find-optimum-u)" "(n-gram.words.hierarchical-dirichlet/find-optimum-u)" "(map char (concat (range 1 125) ))" "(map char (concat 32 (range 49 59) (range 65 91) (range 97 123)  ))" "(map char (concat (range 32 32 )(range 49 59) (range 65 91) (range 97 123)  ))" "(map char (concat (range 32 33 )(range 48 58) (range 65 91) (range 97 123)  ))" "(map char (concat (range 32 33 )(range 48 58) (range 97 123)  ))" "(first  (map char (concat (range 32 33 )(range 48 58) (range 97 123)  )))" "(second (map char (concat (range 32 33 )(range 48 58) (range 97 123)  )))" "(take 2 (map char (concat (range 32 33 )(range 48 58) (range 97 123)  )))" "(str (take 2 (map char (concat (range 32 33 )(range 48 58) (range 97 123)  ))))" "(str (first (take 2 (map char (concat (range 32 33 )(range 48 58) (range 97 123)  )))))  (second (take 2 (map char (concat (range 32 33 )(range 48 58) (range 97 123)  ))))" "letter-pairs" "(nth 1 letter-pairs)" "(nth 3 (map char (concat (range 32 33 )(range 48 58) (range 97 123)  )))" "(map char (concat (range 32 33 )(range 48 58) (range 97 123)  ))" "(def all-letters (map char (concat (range 32 33 )(range 48 58) (range 97 123)  )))" "(nth 3 all-letters)" "(nth all-letters 3)" "(nth [1 2 3] 1))" "(nth [1 2 3] 1)" "(defn make-the-letters [the-letters group-length current-index]\\n  (let [no-of-letters (count the-letters)] (if (> group-length 0) (if (< current-index no-of-letters) (cons (nth the-letters current-index) (make-the-letters the-letters (dec group-length) 00))\\n                                                                    (cons (nth the-letters (inc current-index)) (make-the-letters the-letters (dec group-length) 0))))))" "(trampoline\\n  (make-the-letters [\\"a\\" \\"b\\" \\"c\\" \\"d\\" \\"e\\"] 2 0))" "(trampoline\\n  make-the-letters [\\"a\\" \\"b\\" \\"c\\" \\"d\\" \\"e\\"] 2 0)" "(clojure.contrib.combinatorics/cartesian-product (repeat 2 [\\"a\\" \\"b\\" \\"c\\" \\"d\\" \\"e\\"]))" "(combinations [\\"a\\" \\"b\\" \\"c\\" \\"d\\" \\"e\\"] 2)" "(n-gram.misc.misc-functions/combinations [\\"a\\" \\"b\\" \\"c\\" \\"d\\" \\"e\\"] 2)" "(n-gram.misc.misc-functions/selections [\\"a\\" \\"b\\" \\"c\\" \\"d\\" \\"e\\"] 2)" "all-chars" "cll-char-pairs" "all-char-pairs" "(reduce str all-char-pairs)" "(reduce \#(str %) all-char-pairs)" "(str (first all-char-pairs))" "all-char-pairs" "(reduce str (first all-char-pairs)))" "(reduce str (first all-char-pairs))" "(reduce \#(reduce str %) all-char-pairs)" "(apply \#(reduce str %) all-char-pairs)" "(maaap \#(reduce str %) all-char-pairs)" "(map \#(reduce str %) all-char-pairs)" "all-char-pairs" "letters" "(update-counts-map all-char-pairs counts-ASCII-2)" "(n-gram.letters.letter-maker/update-counts-map all-char-pairs counts-ASCII-2)" "all-char-counts" "(char 1)" "(str 1)" "(str (char 1)" "(str (char 1))" "all-chars" "all-char-counts" "all-char-pair-counts" "(max-key all-char-pairs)" "(max-key val all-char-pairs)" "(apply max-key val all-char-pairs)" "(alpha-MP-memo (apply max-key val all-char-pairs))" "(alpha-MP-memo (find-all-u-memo initial-alpha))" "(equal initial-alpha 0.0 2)" "(find-all-u-memo 0.0)" "(u-i-MP 0.0 \\"ab\\")" "(vals (F-w2-given-w1-me\\"aaaaaaaaab\\"))" "(vals (F-w2-given-w1-me\\"ab\\"))" "(vals (F-w2-given-w1-memo \\"ab\\"))" "(all-char-pair-counts \\"ab\\")" "(key (first all-char-pair-counts))" "(key (nth all-char-pair-counts 20))" "(key (last all-char-pair-counts))" "(key (butlast all-char-pair-counts))" "(second (key (last all-char-pair-counts)))" "alpha-optimum" "(n-gram.letters.hierarchical-dirichlet/alpha-optimum" "n-gram.letters.hierarchical-dirichlet/alpha-optimum" "n-gram.letters.hierarchical-dirichlet/m-optimum" "all-char-pairs" "(zipmap all-char-pairs (map \#(P (str (second %)) (str (first %)) alpha-optimum m-optimum) all-char-pairs))" "(zipmap all-char-pairs (map \#(n-gram.letters.hierarchical-dirichlet/P (str (second %)) (str (first %)) alpha-optimum m-optimum) all-char-pairs))" "(zipmap all-char-pairs (map \#(n-gram.letters.hierarchical-dirichlet/P (str (second %)) (str (first %)) n-gram.letters.hierarchical-dirichlet/alpha-optimum n-gram.letters.hierarchical-dirichlet/m-optimum) all-char-pairs))" "(defn P ([w2 w1 alpha m] (let [F-w2-w1 (get-count-memo all-char-pair-counts [w2 w1]) F-w1 (get-count-memo all-char-counts [w1]) m-i (find-m-i-memo [w2] m) the-f-w2-w1 (f-w2-w1-memo F-w2-w1 F-w1) lambda-w1 (lambda-memo F-w1 alpha)]\\n                    (+ (* lambda-w1 m-i) (* (- 1 lambda-w1) the-f-w2-w1))))\\n([w2 w1] (let [F-w2-w1 (get-count-memo all-char-pair-counts [w2 w1]) F-w1 (get-count-memo all-char-counts [w1]) m-i (find-m-i-memo [w2] m-optimum) the-f-w2-w1 (f-w2-w1-memo F-w2-w1 F-w1) lambda-w1 (lambda-memo F-w1 alpha-optimum)]\\n                   (+ (* lambda-w1 m-i) (* (- 1 lambda-w1) the-f-w2-w1)))))\\n\\n(def P-memo (memoize P))" "(defn K \\"Returns K (MacKay and Peto Equation 34)\\" [alpha] \\n  (let [count-vals (vals all-char-counts)]\\n  (+ (sum  (map \#(Math/log (/ (+ % alpha) alpha)) count-vals)) (* 0.5 (sum (map \#(/ % (* alpha (+ % alpha))) count-vals))))))\\n\\n(def K-memo \\"Memoized K\\" (memoize K))\\n  \\n(defn F-w2-given-w1  \\"Returns all counts of bigrams with word w2 as the second word\\" [w2] (zipmap (map key all-char-pair-counts)\\n(map \#(if (\= (str (second (key %))) w2) (val %) 0.0) all-char-pair-counts)))\\n\\n(def F-w2-given-w1-memo \\"Memoized F-w2-given-w1\\" (memoize F-w2-given-w1))\\n\\n(defn V-i \\"Returns the number of entries in row 'i' of F-w2-given-w1 that are non-zero\\" [F-w2-w1] (sum (map \#(if (< % 1) 0 1) F-w2-w1)))\\n\\n(def V-i-memo \\"Memoized V-i\\" (memoize V-i))\\n\\n(defn N-f-i \\"Returns the number of contexts w1 such that F-w2-given-w1 is greater than or equal to f\\"\\n  [f F-w2-w1] (sum (map \#(if (>\= f %) 0 1) F-w2-w1)))\\n\\n(def N-f-i-memo \\"Memoized N-f-i\\" (memoize N-f-i))\\n\\n(defn find-F-max \\"Returns the largest F such that N-f-i is greater than zero\\" [F-w2-w1 f] (if (> (N-f-i-memo f F-w2-w1) 0) (find-F-max F-w2-w1 (inc f)) f))\\n\\n(def find-F-max-memo \\"Memoized find-F-max\\" (memoize find-F-max))\\n\\n(defn G-i \\"Returns G-i (MacKay and Peto Equation 32)\\" [i] (let [F-w2-w1 (F-w2-given-w1-memo i) F-vals (vals F-w2-w1) F-min 2 F-max (find-F-max-memo F-vals F-min) f-vector (take (- F-max (dec F-min)) (iterate inc F-min))]\\n                (sum (map \#(/ (N-f-i-memo % F-vals) (- % 1)) f-vector))))\\n\\n(def G-i-memo \\"Memoized G-i\\" (memoize G-i))\\n\\n(defn H-i \\"Returns H-i (MacKay and Peto Equation 33)\\" [i] (let [F-w2-w1 (F-w2-given-w1-memo i) F-vals (vals F-w2-w1) F-min 2 F-max (find-F-max-memo F-vals F-min) f-vector (take (- F-max (dec F-min)) (iterate inc F-min))]\\n                (sum (map \#(/ (N-f-i-memo % F-vals)(Math/pow (- % 1) 2)) f-vector))))\\n\\n(def H-i-memo \\"Memoized H-i\\" (memoize H-i))\\n  \\n(defn u-i-MP \\"Returns the optimal value for u-i\\" [alpha i] (let [F-w2-w1 (vals (F-w2-given-w1-memo i)) V (V-i-memo F-w2-w1) K-alpha (K-memo alpha) G (G-i-memo i) H (H-i-memo i)] (/ (* 2 V) (+ K-alpha (- G) \\n                                                                                                 (java.lang.Math/sqrt (+ (Math/pow (- K-alpha G) 2) (* 4 H V)))))))\\n\\n(def u-i-MP-memo \\"Memoized u-i-MP\\" (memoize u-i-MP))\\n\\n(defn alpha-MP \\"Returns alpha based on the u-i values inputted\\" [u] (sum (vals u)))\\n\\n(def alpha-MP-memo \\"Memoized alpha\\" (memoize alpha-MP))\\n\\n(def initial-alpha 20)\\n\\n(defn find-all-u [alpha] (zipmap (keys all-char-counts) (map \#(u-i-MP-memo alpha %) (keys all-char-counts))))\\n\\n(def find-all-u-memo \\"Memoized find-all-u\\" (memoize find-all-u))\\n\\n(defn find-optimum-u ([] (let [u (find-all-u-memo initial-alpha) alpha (alpha-MP-memo u)] (if (equal initial-alpha alpha 2) u (find-optimum-u alpha))))\\n  ([old-alpha] (let [u (find-all-u-memo old-alpha) alpha (alpha-MP-memo u)] (if (equal old-alpha alpha 2) u (find-optimum-u alpha)))))\\n\\n(def find-optimum-u-memo \\"Memoized find-optimum-u\\" (memoize find-optimum-u))\\n\\n\\n(defn find-all-m [alpha u] (zipmap (keys u) (map \#(/ % alpha) (vals u))))\\n\\n(def find-all-m-memo (memoize find-all-m))\\n\\n(defn lambda [F-w1 alpha] (/ alpha (+ F-w1 alpha)))\\n\\n(def lambda-memo (memoize lambda))\\n\\n(defn f-w2-w1 [F-w2-w1 F-w1] (if (\= 0 F-w2-w1) 0 (/ F-w2-w1 F-w1)))\\n\\n(def f-w2-w1-memo (memoize f-w2-w1))\\n\\n(defn find-m-i [i m] (m i))\\n\\n(def find-m-i-memo (memoize find-m-i))\\n\\n(def u-optimum (find-optimum-u-memo))\\n\\n(def alpha-optimum (alpha-MP-memo u-optimum))\\n\\n(def m-optimum (find-all-m-memo alpha-optimum u-optimum))\\n\\n(defn P ([w2 w1 alpha m] (let [F-w2-w1 (get-count-memo all-char-pair-counts [w2 w1]) F-w1 (get-count-memo all-char-counts [w1]) m-i (find-m-i-memo [w2] m) the-f-w2-w1 (f-w2-w1-memo F-w2-w1 F-w1) lambda-w1 (lambda-memo F-w1 alpha)]\\n                    (+ (* lambda-w1 m-i) (* (- 1 lambda-w1) the-f-w2-w1))))\\n([w2 w1] (let [F-w2-w1 (get-count-memo all-char-pair-counts [w2 w1]) F-w1 (get-count-memo all-char-counts [w1]) m-i (find-m-i-memo [w2] m-optimum) the-f-w2-w1 (f-w2-w1-memo F-w2-w1 F-w1) lambda-w1 (lambda-memo F-w1 alpha-optimum)]\\n                   (+ (* lambda-w1 m-i) (* (- 1 lambda-w1) the-f-w2-w1)))))\\n\\n(def P-memo (memoize P))" "(P \\"a\\" \\"b\\" alpha-optimum m-optimum)" "(get-count-memo all-char-pair-counts [\\"a\\" \\"b\\"])" "(get-count-memo all-char-pair-counts (str \\"a\\" \\"b\\"))" "(defn P ([w2 w1 alpha m] (let [F-w2-w1 (get-count-memo all-char-pair-counts (str w1 w2)) F-w1 (get-count-memo all-char-counts w1) m-i (find-m-i-memo w2 m) the-f-w2-w1 (f-w2-w1-memo F-w2-w1 F-w1) lambda-w1 (lambda-memo F-w1 alpha)]\\n                    (+ (* lambda-w1 m-i) (* (- 1 lambda-w1) the-f-w2-w1))))\\n([w2 w1] (let [F-w2-w1 (get-count-memo all-char-pair-counts (str w2 w1)) F-w1 (get-count-memo all-char-counts w1) m-i (find-m-i-memo w2 m-optimum) the-f-w2-w1 (f-w2-w1-memo F-w2-w1 F-w1) lambda-w1 (lambda-memo F-w1 alpha-optimum)]\\n                   (+ (* lambda-w1 m-i) (* (- 1 lambda-w1) the-f-w2-w1)))))\\n\\n(def P-memo (memoize P))" "(get-count-memo all-char-counts \\"a\\")" "(find-m-i-memo \\"b\\" m-optimum)" "(let [F-w2-w1 (get-count-memo all-char-pair-counts (str w1 w2)) F-w1 (get-count-memo all-char-counts w1) m-i (find-m-i-memo w2 m) the-f-w2-w1 (f-w2-w1-memo F-w2-w1 F-w1) lambda-w1 (lambda-memo F-w1 alpha)]" "(let [F-w2-w1 (get-count-memo all-char-pair-counts (str w1 w2)) F-w1 (get-count-memo all-char-counts w1) m-i (find-m-i-memo w2 m) the-f-w2-w1 (f-w2-w1-memo F-w2-w1 F-w1) lambda-w1 (lambda-memo F-w1 alpha)])" "(let [F-w2-w1 (get-count-memo all-char-pair-counts (str \\"a\\" \\"b\\")) F-w1 (get-count-memo all-char-counts \\"a\\") m-i (find-m-i-memo \\"b\\" m-optimum) the-f-w2-w1 (f-w2-w1-memo F-w2-w1 F-w1) lambda-w1 (lambda-memo F-w1 alpha-optimum)])" "F-w2-w1 (get-count-memo all-char-pair-counts (str \\"a\\" \\"b\\"))" "(get-count-memo all-char-counts \\"a\\")" "(find-m-i-memo \\"b\\" m-optimum)" "(f-w2-w1-memo 4 389)" "(lambda-memo 389\\n             alpha-optimum)" "(+ (* 0.016316422360590423 0.01260724026522865) (* (- 1 0.016316422360590423) (/ 4 389)))" "(P \\"a\\" \\"b\\" alpha-optimum m-optimum)" "(P \\" \\" \\" \\" alpha-optimum m-optimum)" "(P \\" . \\n\\" \\" \\" alpha-optimum m-optimum)" "(P \\"5\\" \\"b\\" alpha-optimum m-optimum)" "(P \\"y\\" \\"q\\" alpha-optimum m-optimum)" "(map \#(P (str (second %)) (str (first %)) alpha-optimum m-optimum) all-char-pairs))" "(zipmap [\\"a\\" \\"b\\" \\"c\\"] [1 2 3])" "all-char-pairs" "(count (map \#(P (str (second %)) (str (first %)) alpha-optimum m-optimum) all-char-pairs)))" "(count (map \#(P (str (second %)) (str (first %)) alpha-optimum m-optimum) all-char-pairs))" "(count all-char-pairs)" "map-of-pairs-probs" "(predict-next-letter \\"lion\\" 10)" "(next-letter \\"lion\\" map-of-pairs-probs)" "(find-letter-pair \\"lion\\" map-of-pairs-probs)" "(map \#(if (\= (str(first (key %))) \\"n\\")\\n                                           (val %) 0.0) all-char-pair-counts)" "(find-letter-pair \\"lion\\" map-of-pairs-probs)" "map-of-pairs-probs" "(str (first (key (first map-of-pairs-probs))))" "(find-letter-pair \\"n\\" map-of-pairs-probs)" "(str (last \\"lion\\"))" "(predict-next-letter \\"lion\\" 10)" "(next-letter \\"lion\\" 10 map-of-pairs-probs)" "(next-letter \\"lion\\" map-of-pairs-probs)" "(key (apply max-key val (find-letter-pair-memo (str (last \\"lion\\")) map-of-pairs-probs)))" "(key (apply max-key val (find-letter-trio-memo (str (butlast \\"lion\\")) \\n                                                                  (str (last \\"lion\\")) map-of-pairs-probs)))" "(find-letter-trio (str (butlast \\"lion\\")) (str (last \\"lion\\")) map-of-pairs-probs)" "(str (first (key (first map-of-pairs-probs))))" "formattedText" "n-gram.words.file-reader/formattedText" "(key (apply max-key val (find-letter-trio-memo (str (butlast \\"lion\\")) \\n                                                                  (str (last \\"lion\\")) map-of-pairs-probs)))" "map-of-pairs-probs" "(predict-next-letter \\"lion\\" 10)" "(next-letter \\"n\\" map-of-pairs-probs)" "(next-letter \\"on\\" map-of-pairs-probs)" "(next-letter \\"nd\\" map-of-pairs-probs)" "(next-letter \\"d \\" map-of-pairs-probs)" "(predict-next-letter \\"lion\\" 10)" "(loop-next-letters \\"on\\" 10 map-of-pairs-probs)" "(predict-next-letter \\"Dorothy\\" 10)" "(n-gram.letters.hierarchical-dirichlet/predict-next-letter \\"Dorothy\\" 10)" "(n-gram.letters.hierarchical-dirichlet/predict-next-letter \\"Doroth\\" 10)" "n-gram.words.word-maker" "letters" "counts-ASCII-1" "all-char-counts" "all-char-pair-counts" "(make-letter-groups formattedText 10)" "(make-letter-groups n-gram.words.file-reader/formattedText 10)" "(map \#(reduce str %) (selections n-gram.letters.file-reader/all-chars 10))" "(make-letter-groups n-gram.words.file-reader/formattedText 10)" "(map \#(reduce str %) (selections all-chars 4))" "(map \#(reduce str %) (selections all-chars 3))" "(map \#(reduce str %) (selections all-chars 4))" "(map \#(reduce str %) (selections all-chars 5))" "(predict-next-letter \\"lion\\" 10)" "(predict-next-letter \\"lion\\" 1)" "(predict-next-letter \\"lion\\" 2)" "(predict-text \\"lion\\" 1 map-of-pairs-probs_" "(predict-text \\"lion\\" 1 map-of-pairs-probs)" "(next-letter \\"on\\" map-of-pairs-probs)" "(next-letter \\"n \\" map-of-pairs-probs)" "(next-letter \\" t\\n\\" map-of-pairs-probs)" "(next-letter \\" t\\" map-of-pairs-probs)" "(next-letter \\"th\\" map-of-pairs-probs)" "(next-letter \\"he\\" map-of-pairs-probs)" "(next-letter \\"e \\" map-of-pairs-probs)" "map-of-pairs-probs" "(apply max-key val map-of-pairs-probs)" "(map-of-pairs-probs \\"th\\")" "(map-of-pairs-probs \\"e \\")" "(map-of-pairs-probs \\" t\\")" "(map-of-pairs-probs \\" a\\")" "(map-of-pairs-probs \\" b\\")" "(map-of-pairs-probs \\" c\\")" "(map-of-pairs-probs \\" e\\")" "(sort-by key map-of-pairs-probs)" "(take 36 (sort-by key map-of-pairs-probs))" "(apply max-key val (take 36 (sort-by key map-of-pairs-probs)))" "var p \= require('persistent-hash-trie')\\n\\nvar trie \= p.Trie()" "p \= require('persistent-hash-trie')" "(build_tree n-gram.words.file-reader/formattedText)" "n-gram.words.file-reader/formattedText" "(take 1000 n-gram.words.file-reader/formattedText)" "(str (take 1000 n-gram.words.file-reader/formattedText))" "(str (reduce str (take 1000 n-gram.words.file-reader/formattedText)))" "(def short-text (str (reduce str (take 1000 n-gram.words.file-reader/formattedText))))" "(build_tree short-text)" "(def short-text (str (reduce str (take 20 n-gram.words.file-reader/formattedText))))" "(def tree-root (build_tree short-text))" "(inspect-tree tree-root)" "(use clojure.inspector)" "(inspect-tree tree-root)" "(n-gram.misc.misc-functions\\\\inspect-tree tree-root)" "n-gram.words.file-reader/formattedText" "(def short-text (str (reduce str (take 20 n-gram.words.file-reader/formattedText))))" "short-text" "(def short-text (str (reduce str (take 100 n-gram.words.file-reader/formattedText))))" "short-text" "(def tree-root (build_tree short-text))" "(inspect-tree tree-root)" "(use 'clojure.inspector)" "(def short-text (str (reduce str (take 100 n-gram.words.file-reader/formattedText))))" "(def tree-root (build_tree short-text))" "(is_sub tree-root \\"dorothy\\")" "(is_sub tree-root \\"doroiiiiiehy\\")" "(how_many tree-root \\"the\\")" "(longest_repeating_substring tree-root)" "(longest_repeating_substring (build_tree \\"aaa b aaa n aaanbsh\\"))" "(longest_repeating_substring (build_tree \\"abc hbc tujnabc\\"))" "(longest_repeating_substring (build_tree \\"abc habc tujnabc\\"))" "(longest_repeating_substring (build_tree \\"abc defg habc defg tujnabc defg\\"))" "(longest_repeating_substring (build_tree \\"abcdefg habc defg tujnabcjdefg\\"))" "(hash-map)" "(has-set)" "(hash-set)" "(def new-node (build_node))" "new-node" "(update-in new-node [\:idx_start] conj 1)" "new-node" "(update-in \\n          (update-in new-node [\:idx_start] conj idx)\\n            [\:cnt] inc)" "(update-in \\n          (update-in new-node [\:idx_start] conj 10)\\n            [\:cnt] inc)" "(def newer-node (update-in \\n                          (update-in new-node [\:idx_start] conj 10)\\n                            [\:cnt] inc))" "newer-node" "(update-in \\n          (update-in newer-node [\:idx_start] conj 11)\\n            [\:cnt] inc)" "(get-in new-node [\:next (first \\"the\\")] (build_node))" "(def newest-node (get-in new-node [\:next (first \\"the\\")] (build_node)))" "newest-node" "newest-node [\:next]" "(first \\"the\\")" "(let [next_node (get-in new-node [\:next (first \\"the\\")] (build_node))]\\n        (assoc-in \\n          (update-in \\n            (update-in new-node [\:idx_start] conj 2)\\n              [\:cnt] inc)\\n          [\:next (first \\"the\\")] \\n          (build_suffix (subs \\"the\\" 1) next_node 2))\\n        )" "(let [next_node (get-in new-node [\:next (first \\"there\\")] (build_node))]\\n        (assoc-in \\n          (update-in \\n            (update-in new-node [\:idx_start] conj 2)\\n              [\:cnt] inc)\\n          [\:next (first \\"there\\")] \\n          (build_suffix (subs \\"there\\" 1) next_node 2))\\n        )" "new-node" "newer-node" "(update-in newer-node [\:next] (char \\"t\\"))" "(update-in newer-node [\:next] \\\\t)" "(def newer-node (node. \\\\t 0 0))" "newer-node" "(def newer-node (node. (hash-map. \\\\t) (hash-set.0) 0)" "(def newer-node (node. (hash-map. \\\\t) (hash-set.0) 0))" "(hash-map \\\\t)" "(def newer-node (build_node))" "(def newer-node (assoc-in newer-node [\:next] (first \\"the\\")))" "newer-node" "(get-in newer-node [\:next (first \\"the\\")])" "(def newer-node (assoc-in newer-node [\:next (first \\"the\\")]))" "(def newer-node (build_node))" "(def newer-node (assoc-in newer-node [\:next (first \\"the\\")]))" "(hash-map (first \\"the\\"))" "(build_tree \\"mississippi\\")" "(def mississippi (build_tree \\"mississippi\\"))" "mississippi" "(mississippi [\:idx_start 0])" "(get-in mississippi [\:idx_start 0])" "(get-in mississippi [\:next \\"m\\"])" "(get-in mississippi [\:next \\\\m])" "(get-in mississippi [\:next \\\\i])" "(get-in mississippi [\:next \\\\s])" "(get-in mississippi [\:next \\\\p])" "(count (get-in mississippi [\:next \\\\p]))" "(first (get-in mississippi [\:next \\\\p]))" "(second (get-in mississippi [\:next \\\\p]))" "(last (get-in mississippi [\:next \\\\p]))" "(count ((get-in mississippi [\:next \\\\p])[\:next]))" "new-node" "(new-node [\:next])" "new-node [\:next]" "(get new-ode [\:next])" "(get new-node [\:next])" "(count (get (get-in mississippi [\:next \\\\p])[\:next]))" "(get (get-in mississippi [\:next \\\\p])[\:nex)" "(get (get-in mississippi [\:next \\\\p])[\:next])" "(first (get-in mississippi [\:next \\\\p]))" "(second (get-in mississippi [\:next \\\\p]))" "(get (first (get-in mississippi [\:next \\\\p])) [\:next])" "(first (first (get-in mississippi [\:next \\\\p])) )" "(second (first (get-in mississippi [\:next \\\\p])) )" "(get (second (first (get-in mississippi [\:next \\\\p])) ) [\:next])" "(first (second (first (get-in mississippi [\:next \\\\p])) ) )" "(first (first (second (first (get-in mississippi [\:next \\\\p])) ) ))" "(second (first (second (first (get-in mississippi [\:next \\\\p])) ) ))" "(get (second (first (second (first (get-in mississippi [\:next \\\\p])) ) )) [\:next])" "(first (second (first (second (first (get-in mississippi [\:next \\\\p])) ) ))" "(first (second (first (second (first (get-in mississippi [\:next \\\\p])) ) )))" "(print-tree mississippi)" "mississippi" "(first mississippi)" "mississippi" "(unique \\"mississippi\\")" "(distinct \\"mississippi\\")" "(get \\"mississippi\\" \\"m\\")" "(get \\"mississippi\\" \\\\m)" "(\\"mississippi\\" \\"m\\")" "(\\"mississippi\\" \\\\m)" "(clojure.string/split \\"mississippi\\")" "(clojure.string/split \\"mississippi\\" \\"\\")" "(re-find \\"mississippi\\" \\"m\\")" "(re-find \\"mississippi\\" \#\\"m\\")" "(re-find \#\\"mississippi\\" m)" "(re-find \#\\"mississippi\\" \\"m\\")" "(re-find \#\\"m\\" \\"mississippi\\")" "(re-find \#\\"m\\\\w{3}\\" \\"mississippi\\")" "(re-find \#\\"i\\\\w{3}\\" \\"mississippi\\")" "(re-find \#\\"i\\\\w{0,3}\\" \\"mississippi\\")" "(re-find \#\\"p\\\\w{0,3}\\" \\"mississippi\\")" "(re-find \#\\"p\\\\w{3}\\" \\"mississippi\\")" "(re-seq \#\\"p\\\\w{0,3}\\" \\"mississippi\\")" "(re-seq \#\\"i\\\\w{0,3}\\" \\"mississippi\\")" "(re-seq \#\\"i\\" \\"mississippi\\")" "(re-seq \#\\"i|i\\\\w{0,3}\\" \\"mississippi\\")" "(re-seq \#\\"i\\\\w{0,3}\\" \\"mississippi\\")" "(re-seq \#\\"\\\\w{0,3}\\" \\"mississippi\\")" "(re-matches \#\\"\\\\w{0,3}\\" \\"mississippi\\")" "(re-find \#\\"\\\\w{0,3}\\" \\"mississippi\\")" "(re-matcher \#\\"\\\\w{0,3}\\" \\"mississippi\\")" "(def matcher (re-matcher \#\\"\\\\w{0,3}\\" \\"mississippi\\"))" "(re-find matcher)" "(re-groups \#\\"\\\\w{0,3}\\" \\"mississippi\\")" "(re-matches \#\\"\\\\w{0,3}\\" \\"mississippi\\")" "(node. (hash-map) (hash-set) 0)" "(def new-node (node. (hash-map) (hash-set) 0))" "new-node" "(update-in new-new [\:cnt] inc)" "(update-in new-node [\:cnt] inc)" "new-node" "(defn build-suffix ([word] (let [new-tree (build_suffix_tree)] (build-suffix word (new-tree [\:root_node]) new-tree))))" "(build_suffix \\"mum\\")" "(defn build-suffix [word] (let [new-tree (build_suffix_tree)] (build-suffix word (new-tree [\:root_node]) new-tree)))" "(build-suffix \\"mum\\"))))" "(build-suffix \\"mum\\")" "(def new-tree    (build_suffix_tree\\n                   \\n                   \\n                   ))" "(new-tree [\:root_node])" "(get new-tree [\:root_node])" "new_tree" "new-tree" "(get new-tree \:root_node)" "(get-in new-tree [\:root_node nil])" "(def new-node (build_suffix_node))" "new-node" "(def new-node (update-in new-node [\:children] (build_suffix_node)))" "(def new-node (assoc-in new-node [\:children] (build)))" "(def new-node (assoc-in new-node [\:children] (build_suffix_node)))" "new-noode" "new-node" "(def new-node (build_suffix_node))" "(def new-node (assoc-in new-node [\:children \\"m\\"] (build_suffix_node)))" "new-node" "(get-in new-node [\:children \\"m\\"])" "(def new-node (assoc-in new-node [\:children \\"i\\"] (build_suffix_node)))" "new-node" "(def new-node (build_suffix_node))" "(def new-node (update-in new-node [\:value] \\"m\\"))" "(def new-node (build_suffix_node \\"m\\"))" "new-node" "(def new-node (assoc-in new-node [\:children] (build_suffix_node \\"i\\")))" "new-node" "(def new-node (assoc-in new-node [\:children] (build_suffix_node \\"s\\")))" "new-node" "(def new-node (conj (get-in new-node \:children) (build_suffix_node \\"i\\")))" "new-node" "(get-in new-node \:children \\"m\\")" "(get-in new-node \:children)" "(get-in new-node [\:children \\"s\\"])" "(get-in new-node [\:value \\"s\\"])" "(get-in new-node [\:value \\"m\\n\\"])" "(get-in new-node [\:value \\"m\\"])" "(get new-node \:value)" "(get-in new-node \:value)" "(get-in new-node [\:value])" "(get-in new-node [\:value \:value])" "(get-in new-node [\:children \:value])" "new-node" "(def new-node (assoc-in new-node [\:children (get-in new-node [\:children])] (build_suffix_node \\"i\\")))" "new-node" "(def new-node (assoc-in new-node [\:children] (build_suffix_node \\"z\\")))" "new-node" "(get-in new-node [\:children])" "(def new-node (conj new-node [\:children] (build_suffix_node \\"i\\")))" "(def new-node (conj new-node \:children (build_suffix_node \\"i\\")))" "(def new-node (assoc-in new-node [\:children (build_suffix_node \\"i\\")]))" "(def input\\n  {1 {10 {\:id 101 \:name \\"Paul\\"}\\n      20 {}}\\n   2 {30 {} 40 {}}\\n   3 {50 {} 60 {}}})" "input" "(def new-node (assoc-in new-node [\:children (build_suffix_node \\"i\\")] {}))" "new-node" "(def new-node build_suffix_node)" "(def new-node (assoc-in new-node [\:children] (build_suffix_node \\"m\\")))" "new-node" "(def new-node (build_suffix_node)" "(def new-node (build_suffix_node))" "(def new-node (assoc-in new-node [\:children] (build_suffix_node \\"m\\")))" "new-node" "(def new-node (build_suffix_node))" "(def new-node (assoc-in new-node [\:children {}] (build_suffix_node \\"m\\")))" "new-node" "(def new-node (assoc-in new-node [\:children \\"m\\"](build_suffix_node \\"i\\")))" "new-node" "(def new-tree  {})" "new-tree" "(def new-tree (assoc-in new-tree {\\"m\\" [\:cnt 0]}))" "(def new-tree (assoc-in new-tree [\\"m\\" {\:cnt 0}]))" "(def new-tree (assoc-in new-tree [\\"m\\"] {\:cnt 0}))" "new-tree" "(def new-tree (assoc-in new-tree [\\"i\\"] {\:cnt 0}))" "new-tree" "(def new-tree (assoc-in [\\"m\\" \\"i\\"] {\:cnt 0}))" "(def new-tree {root})" "(def new-tree (hash-map))" "(assoc new-tree \\"m\\" {\:cnt 0})" "new-tree" "(def new-tree (assoc new-tree {\\"m\\" {\:cnt 0}}))" "(def new-tree (assoc new-tree \\"m\\" {\:cnt 0}))" "new-tree" "(def new-tree (assoc new-tree \\"i\\" {\:cnt 0}))" "new-tree" "(def new-tree (assoc-in new-tree [\\"m\\" \\"i\\"] {\:cnt 0}))" "new-tree" "(build_suffix_tree \\"m\\")" "(build_suffix_tree \\"mississippi\\")" "(def mississippi-tree (build_suffix_tree \\"mississippi\\"))" "mississippi-tree" "(assoc mississippi-tree \\"ississippi\\" {\:cnt 0})" "(build_suffix_tree \\"mississippi\\")" "(build_suffix_tree \\"m\\")" "(build_suffix_tree \\"mi\\")" "(build_suffix_tree \\"mis\\")" "(build_suffix_tree \\"mist\\")" "(build_suffix_tree \\"misti\\")" "(build_suffix_tree \\"miss\\")" "(build_suffix_tree \\"missi\\")" "(build_suffix_node)" "(def the-node (build_suffix_node))" "(assoc the-node (build_suffix_node \\"mississippi\\"))" "(assoc the-node [\:children] (build_suffix_node \\"mississippi\\"))" "(assoc the-node \:children (build_suffix_node \\"mississippi\\"))" "(def the-node (assoc the-node \:children (build_suffix_node \\"mississippi\\"))" "(def the-node (assoc the-node \:children (build_suffix_node \\"mississippi\\")))" "the-node" "(assoc the-node \:children (build_suffix_node \\"ississippi\\")))" "(assoc the-node \:children (build_suffix_node \\"ississippi\\"))" "(def the-node (build_suffix_node))" "(assoc-in the-node [\:children] (build_suffix_node \\"mississippi\\"))" "(type (get the-node \:children))" "(def the-node (assoc-in the-node [\:children] (build_suffix_node \\"mississippi\\")))" "(type (get the-node \:children))" "(def the-node (build_suffix_node))" "(assoc (get the-node \:children) (build_suffix_node \\"mississippi\\"))" "(assoc (get the-node \:children) 0 (build_suffix_node \\"mississippi\\"))" "(assoc-in the-node [\:children] (build_suffix_node \\"mississippi\\"))" "(assoc-in the-node [\:children] {(build_suffix_node \\"mississippi\\")})" "(merge (the-node \:children) (build_suffix_node \\"mississssippi\\"))" "(assoc-in the-node [\:children \\"mississippi\\"] (build_suffix_node \\"mississippi\\"))" "(def the-node (assoc-in the-node [\:children \\"mississippi\\"] (build_suffix_node \\"mississippi\\")))" "(assoc-in thhe-node [\:children \\"ississippi\\"] (build_suffix_node \\"ississippi\\"))" "(assoc-in the-node [\:children \\"ississippi\\"] (build_suffix_node \\"ississippi\\"))" "(build_suffix_tree \\"mississippi\\")" "(assoc-in (build_suffix_node) [\:children \\"mississippi\\"] (build_suffix_node))" "(build_suffix_tree \\"mississippi\\")" "(def new-tree (build_suffix_tree \\"mississippi\\"))" "(get  new-tree [\:children \\\\i])" "new-tree" "(def new-tree (build_suffix_tree \\"mississippi\\"))" "new-tree" "(build_suffix_tree \\"i\\")" "(build_suffix_tree \\"pi\\")" "(build_suffix_tree (rest \\"pi\\"))" "(build_suffix_tree \\"mississippi\\")" "(rest \\"mississssssippi\\")" "(str (rest \\"mississssssippi\\"))" "(reduce str (rest \\"mississssssippi\\"))" "(build_suffix_tree \\"mississippi\\")" "(count \\"mississippi\\")" "(count (reduce str (rest \\"mississippi\\")))" "(count (reduce str (rest \\"pi\\")))" "(reduce str (rest \\"pi\\"))" "(str rest \\"pi\\")" "(str (rest \\"pi\\"))" "(rest \\"pi\\")" "(str (reduce str (rest \\"pi\\")))" "(build_suffix_tree \\"mississippi\\")" "(def new-tree (build_suffix_tree \\"mississippi\\"))" "(get new-tree [\:children \\"mississippi\\"])" "(get-in new-tree [\:children \\"mississippi\\"])" "(get new-tree \:children)" "(keys (get new-tree \:children))" "new-tree" "(assoc-in new-tree [\:children \\"ippi\\" \\"ay\\"] (build_suffix_node))" "(assoc-in new-tree [\:children \\"ippi\\" \:children \\"ay\\"] (build_suffix_node))" "(re-matches \\"ippi\\" \\"mississippi\\")" "(re-matches (re-pattern \\"ippi\\") \\"mississippi\\")" "(re-find \\"ippi\\" \\"mississippi\\")" "(re-find (re-pattern \\"ippi\\") \\"mississippi\\")" "(re-seq (reduce re-pattern (keys (get new-tree \:children))) \\"mississippi\\")" "(re-pattern (keys (get new-tree \:children)))" "(reduce re-pattern (keys (get new-tree \:children)))" "(keys (get new-tree \:children))" "(apply re-pattern (keys (get new-tree \:children)))" "(doseq re-pattern (keys (get new-tree \:children)))" "(doall re-pattern (keys (get new-tree \:children)))" "(re-pattern (just (keys (get new-tree \:children))))" "(re-pattern (juxt (keys (get new-tree \:children))))" "(map \#(re-pattern %) (keys (get new-tree \:children)))" "(map \#(re-find (re-pattern %) \\"ippi\\") (keys (get new-tree \:children)))" "(map \#(re-find \#% \\"ippi\\") (keys (get new-tree \:children)))" "(map \#(re-find (re-pattern (str \\"^\\" %)) \\"ippi\\") (keys (get new-tree \:children)))" "(map \#(re-find (re-pattern (str \\"^\\" % \\"$\\")) \\"ippi\\") (keys (get new-tree \:children)))" "(map \#(re-find (re-pattern (str \\"^\\" % \\"$\\")) \\"issi\\") (keys (get new-tree \:children)))" "(map \#(re-find (re-pattern (str \\"^\\" %)) \\"issi\\") (keys (get new-tree \:children)))" "(map \#(re-find (re-pattern (str  %)) \\"issi\\") (keys (get new-tree \:children)))" "(map \#(re-find (re-pattern  %) \\"issi\\") (keys (get new-tree \:children)))" "(re-find (re-pattern \\"issi\\") \\"issippi\\")" "(keys (get new-tree \:children))" "(map \#(re-find (re-pattern  %) \\"i\\") (keys (get new-tree \:children)))" "(map \#(re-find (re-pattern  %) \\"s\\") (keys (get new-tree \:children)))" "(map \#(re-find (re-pattern  %) \\"pi\\") (keys (get new-tree \:children)))" "(map \#(re-find (re-pattern  %) \\"ppi\\") (keys (get new-tree \:children)))" "(map \#(re-find (re-pattern  %) \\"ippi\\") (keys (get new-tree \:children)))" "(map \#(re-find (re-pattern (str \\"^\\" %)) \\"ippi\\") (keys (get new-tree \:children)))" "(zipmap (map \#(count %) (map \#(re-find (re-pattern (str \\"^\\" %)) \\"ippi\\") (keys (get new-tree \:children))) (map \#(re-find (re-pattern (str \\"^\\" %)) \\"ippi\\") (keys (get new-tree \:children)))" "(zipmap (map \#(count %) (map \#(re-find (re-pattern (str \\"^\\" %)) \\"ippi\\") (keys (get new-tree \:children)))) (map \#(re-find (re-pattern (str \\"^\\" %)) \\"ippi\\") (keys (get new-tree \:children)))" "(map \#(re-find (re-pattern (str \\"^\\" %)) \\"ippi\\") (keys (get new-tree \:children)))" "(zipmap (map \#(count %) (map \#(re-find (re-pattern (str \\"^\\" %)) \\"ippi\\") (keys (get new-tree \:children)))) (map \#(re-find (re-pattern (str \\"^\\" %)) \\"ippi\\") (keys (get new-tree \:children))))" "(max (map \#(re-find (re-pattern  %) \\"ippi\\") (keys (get new-tree \:children))))" "(maxx(zipmap (map \#(count %) (map \#(re-find (re-pattern (str \\"^\\" %)) \\"ippi\\") (keys (get new-tree \:children)))) (map \#(re-find (re-pattern (str \\"^\\" %)) \\"ippi\\") (keys (get new-tree \:children)))))" "(max(zipmap (map \#(count %) (map \#(re-find (re-pattern (str \\"^\\" %)) \\"ippi\\") (keys (get new-tree \:children)))) (map \#(re-find (re-pattern (str \\"^\\" %)) \\"ippi\\") (keys (get new-tree \:children)))))" "(max (vals (zipmap (map \#(count %) (map \#(re-find (re-pattern (str \\"^\\" %)) \\"ippi\\") (keys (get new-tree \:children)))) (map \#(re-find (re-pattern (str \\"^\\" %)) \\"ippi\\") (keys (get new-tree \:children))))))" "(max (keys (zipmap (map \#(count %) (map \#(re-find (re-pattern (str \\"^\\" %)) \\"ippi\\") (keys (get new-tree \:children)))) (map \#(re-find (re-pattern (str \\"^\\" %)) \\"ippi\\") (keys (get new-tree \:children))))))" "(apply max-key val (zipmap (map \#(count %) (map \#(re-find (re-pattern (str \\"^\\" %)) \\"ippi\\") (keys (get new-tree \:children)))) (map \#(re-find (re-pattern (str \\"^\\" %)) \\"ippi\\") (keys (get new-tree \:children)))))" "(apply max-key key (zipmap (map \#(count %) (map \#(re-find (re-pattern (str \\"^\\" %)) \\"ippi\\") (keys (get new-tree \:children)))) (map \#(re-find (re-pattern (str \\"^\\" %)) \\"ippi\\") (keys (get new-tree \:children)))))" "(search_tree\\n  \\n   \\"ippi\\" new-tree)" "(key (search_tree\\n  \\n        \\"ippi\\" new-tree))" "(key (search_tree\\n  \\n        \\"issi\\" new-tree))" "(keys (get new-tree \:children))" "(map \#(re-find (re-pattern \\"^ipppi\\") %) (keys (get node \:children)))" "(map \#(re-find (re-pattern \\"^ippi\\") %) (keys (get node \:children)))" "(map \#(re-find (re-pattern \\"^ippi\\") %) (keys (get new-tree \:children)))" "(map \#(re-find (re-pattern \\"^issssssi\\") %) (keys (get new-tree \:children)))" "(map \#(re-find (re-pattern \\"^issi\\") %) (keys (get new-tree \:children)))" "(filter (map \#(not (nil? (re-find (re-pattern \\"^issi\\") %))) (keys (get new-tree \:children))))" "(map \#(not (nil? (re-find (re-pattern \\"^issi\\") %))) (keys (get new-tree \:children)))" "(map \#(if-not (nil? (re-find (re-pattern \\"^issi\\") %))) (keys (get new-tree \:children)))" "(map \#(if-not nil? (re-find (re-pattern \\"^issi\\") %)) (keys (get new-tree \:children)))" "(get (if-not nil? (map \#(re-find (re-pattern \\"^issi\\") %) (keys (get new-tree \:children)))))" "(select-keys (map \#(re-find (re-pattern \\"^issi\\") %) (keys (get new-tree \:children))) (not nil))" "(map \#(if (not nil? %) %) (map \#(re-find (re-pattern \\"^issi\\") %) (keys (get new-tree \:children))))" "(map \#(if (not (nil? %)) %) (map \#(re-find (re-pattern \\"^issi\\") %) (keys (get new-tree \:children))))" "( \#(if (not (nil? %)) %) (map \#(re-find (re-pattern \\"^issi\\") %) (keys (get new-tree \:children))))" "(into {} (remove (comp nil? ) (map \#(re-find (re-pattern \\"^issi\\") %) (keys (get new-tree \:children)))))" "(into {} (remove nil?  (map \#(re-find (re-pattern \\"^issi\\") %) (keys (get new-tree \:children)))))" "(type (map \#(re-find (re-pattern \\"^issi\\") %) (keys (get new-tree \:children))))" "(filter not (nil? (map \#(re-find (re-pattern \\"^issi\\") %) (keys (get new-tree \:children)))))" "(filter nil? (map \#(re-find (re-pattern \\"^issi\\") %) (keys (get new-tree \:children))))" " (map \#(re-find (re-pattern \\"^issi\\") %) (keys (get new-tree \:children)))" "(filter not (nil? (map \#(re-find (re-pattern \\"^issi\\") %) (keys (get new-tree \:children)))))" "(filter not nil? (map \#(re-find (re-pattern \\"^issi\\") %) (keys (get new-tree \:children))))" "(filter not (nil?) (map \#(re-find (re-pattern \\"^issi\\") %) (keys (get new-tree \:children))))" "(filter (comp not nil?) (map \#(re-find (re-pattern \\"^issi\\") %) (keys (get new-tree \:children))))" "(search_tree \\"ippi\\" new-tree)" "(def results (search_tree \\"ippi\\" new-tree))" "(vals results)" "(apply merge (for [[k v] results \:when (not (nil? v))] {k v}))" "(def results (search_tree \\"issi\\" new-tree))" "(apply merge (for [[k v] results \:when (not (nil? v))] {k v}))" "(search_tree \\"issi\\" new-tree)" "(search_tree \\"ippi\\" new-tree)" "(search_tree \\"i\\" new-tree)" "(is-exact-match \\"ippi\\" new-tree)" "(type (search_tree \\"ippi\\" new-tree))" "(key (search_tree \\"ippi\\" new-tree))" "(first (search_tree \\"ippi\\" new-tree))" "(is-exact-match \\"ippi\\" new-tree)" "(is-exact-match \\"issi\\" new-tree)" "new-tree" "(dissoc new-tree \:children \\"i\\")" "(reduce (fn [m k] (remove-key k m)) {\:foo 1 \:bar 2 \:baz 3} [\:foo \:bar])" "(defn remove-key [key map]\\n  (into {}\\n        (remove (fn [[k v]] (\#{key} k))\\n                map)))" "(reduce (fn [m k] (remove-key k m)) {\:foo 1 \:bar 2 \:baz 3} [\:foo \:bar])" "(reduce (fn [m k] (remove-key k m)) new-tree \:children \\"i\\")" "(dissoc\! new-tree \:children \\"i\\")" "(dissoc\!new-tree [\:children \\"i\\"])" "(dissoc\! new-tree [\:children \\"i\\"])" "(dissoc new-tree [\:children \\"i\\"])" "(branch_node new-tree \\"i\\" \\"mi\\")" "new-tree" "(def new-tree (build_suffix_tree \\"the\\"))" "new-tree" "(dissoc new-tree [\:children \\"e\\"])" "(defn dissoc-in\\n  [m [k & ks]]\\n  (if-not ks\\n    (dissoc m k)\\n    (assoc m k (dissoc-in (m k) ks))))" "(dissoc-in new-tree [\:children \\"e\\"])" "(get new-tree \:children)" "(keys (get new-tree \:children))" "(get-in new-tree [\:children \\"e\\"])" "(defn dissoc-in\\n  \\"Dissociates an entry from a nested associative structure returning a new\\n  nested structure. keys is a sequence of keys. Any empty maps that result\\n  will not be present in the new structure.\\"\\n  [m [k & ks \:as keys]]\\n  (if ks\\n    (if-let [nextmap (get m k)]\\n      (let [newmap (dissoc-in nextmap ks)]\\n        (if (seq newmap)\\n          (assoc m k newmap)\\n          (dissoc m k)))\\n      m)\\n    (dissoc m k)))" "(dissoc-in new-tree [\:children \\"e\\"])" "(branch_node new-tree \\"he\\" \\"h\\")" "(dissoc-in new-tree [\:children \\"he\\"])" "(assoc-in new-tree [\:children \\"h\\"] (build_suffix_node))" "(branch_node new-tree \\"he\\" \\"h\\")" "(search_tree \\"a\\" new-tree)" "(search_tree \\"h\\" new-tree)" "(search_tree \\"hea\\" new-tree)" "(re-find \#\\"^hea\\" \\"he\\"\\"\\")" "(re-find \#\\"^hea\\" \\"he\\")" "(re-find \#\\"^he\\" \\"he\\")" "(re-find \#\\"^h\\" \\"he\\")" "(search_tree \\"hea\\" new-tree)" "new-tree" "(update-in new-tree [\:children \\"the\\" \:cnt] inc)" "(build_suffix_tree \\"theh\\")" "(count \\"h\\")" "(search_tree \\"h\\" new-tree)" "(nil?(search_tree \\"h\\" new-tree))" "(is_exact_match (search_tree \\"h\\" new-tree))" "(build_suffix_tree \\"theh\\")" "(build_suffix_tree \\"the\\")" "(count \\"theh\\")" "(build_suffix_tree \\"thehhh\\" (build_suffix_node))" "(assoc-in (build_suffix_node [\:children \\"theh\\"] (build_suffix_node)))" "(assoc-in (build_suffix_node) [\:children \\"theh\\"] (build_suffix_node))" "(def the-tree (assoc-in (build_suffix_node) [\:children \\"theh\\"] (build_suffix_node))" "(def the-tree (assoc-in (build_suffix_node) [\:children \\"theh\\"] (build_suffix_node)))" "the-tree" "(search_tree \\"the\\" the-tree)" "(nil? (search_tree \\"the\\" the-tree))" "(is_exact_match (search_tree \\"the\\" the-tree))" "(re-find (re-pattern (str \\"^\\" (key (search_tree \\"the\\" the-tree)) \\"$\\")) (val (search_tree \\"the\\" the-tree)))" "(key (search_tree \\"the\\" the-tree))" "(key (first (search_tree \\"the\\" the-tree)))" "(build_suffix_tree \\"theh\\")" "(is_exact_match (first (search_tree \\"the\\" the-tree)))" "(> (count \\"the\\") (count (second (is_exact_match (first (search_tree \\"the\\" the-tree))))))" "(subs \\"the\\" 0 1)" "(subs \\"the\\" 0 2)" "(build_suffix_tree \\"theh\\")" "(build_suffix_tree \\"the\\")" "(build_suffix_tree \\"th\\")" "(build_suffix_tree \\"t\\")" "the-tree" "(search_tree \\"the\\" the-tree)" "(is_exact_match (first (search_tree \\"the\\" the-tree)))" "(key (first (search_tree \\"the\\" the-tree)))" "(val (first (search_tree \\"the\\" the-tree)))" "(build_suffix_tree \\"theh\\")" "the-tree" "(build_suffix_tree \\"theh\\")" "(search_tree \\"h\\" (build_suffix_node))" "(get (build_suffix_node) \:children)" "(zipmap {} {})" "(map \#(re-find (re-pattern (str \\"^\\" word)) %) (get (build_suffix_node) \:children))" "(map \#(re-find (re-pattern (str \\"^\\" \\"h\\")) %) (get (build_suffix_node) \:children))" "(zipmap {} (map \#(re-find (re-pattern (str \\"^\\" \\"h\\")) %) (get (build_suffix_node) \:children)))" "(apply merge (for [[k v] (zipmap {} (map \#(re-find (re-pattern (str \\"^\\" \\"h\\")) %) (get (build_suffix_node) \:children))) \:when (not (nil? v))] {k v}))" "(search_tree \\"\\" (build_suffix_node))" "(build_suffix_tree \\"theh\\")" "(def new-tree (build_suffix_node))" "(search \\"h\\" new-tree)" "(search_tree \\"h\\" new-tree)" "(def new-tree (assoc-in new-tree [\:children \\"h\\"] (build_suffix_node)))" "new-tree" "(search_tree \\"eh\\" new-tree)" "(keys (get new-tree \:children))" "(map \#(re-find (re-pattern (str \\"^\\" \\"eh\\")) %) (keys (get new-tree \:children)))" "(nil? {})" "(apply merge (for [[k v] (zipmap (keys (get new-tree \:children)) (map \#(re-find (re-pattern (str \\"^\\" \\"eh\\")) %) (keys (get new-tree \:children)))) \:when (not (nil? v))] {k v}))" "(apply merge (for [[k v] (zipmap (keys (get new-tree \:children)) (map \#(re-find (re-pattern (str \\"^\\" \\"h\\")) %) (keys (get new-tree \:children)))) \:when (not (nil? v))] {k v}))" "(apply merge (for [[k v] (zipmap (keys (get new-tree \:children)) (map \#(re-find (re-pattern (str \\"^\\" \\"e\\")) %) (keys (get new-tree \:children)))) \:when (not (nil? v))] {k v}))" "(search_tree \\"eh\\" new-tree)))" "(search_tree \\"eh\\" new-tree)" "(def children (keys (get new-tree \:children)))" "children" "(apply merge (for [[k v] (zipmap children (map \#(re-find (re-pattern (str \\"^\\" \\"eh\\")) %) children)) \:when (not (nil? v))] {k v}))" "(def results (apply merge (for [[k v] (zipmap children (map \#(re-find (re-pattern (str \\"^\\" \\"eh\\")) %) children)) \:when (not (nil? v))] {k v})))" "(and (nil? results) (> (count \\"eh\\") 1))" "(subs \\"eh\\" 0 (count \\"eh\\"))" "(subs \\"eh\\" 0 2)" "(subs \\"eh\\" 0 1)" "(subs \\"tree\\" 1 4)" "(build_suffix_tree \\"theh\\")" "(def theh-tree (build_suffix_tree \\"theh\\"))" "(search_tree \\"heh\\" theh-tree)" "(is_exact_match (search_tree \\"heh\\" theh-tree))" "(is_exact_match (first (search_tree \\"heh\\" theh-tree)))" "(search_tree \\"heh\\" theh-tree)" "[\\"heh\\" {\\"h\\" \\"h\\"}]" "(search_tree \\"heh\\" theh-tree)" "(search_tree \\"eh\\" theh-tree)" "(search_tree \\"h\\" theh-tree)" "(build_suffix_tree \\"theh\\")" "(build_suffix_tree \\"thehU\\")" "(build_suffix_tree \\"mississippi\\")" "(build_suffix_tree \\"i\\")" "(build_suffix_tree \\"pi\\")" " (build_suffix_tree (str (reduce str (rest \\"pi\\"))) (build_suffix_node))" "(def i-tree  (build_suffix_tree (str (reduce str (rest \\"pi\\"))) (build_suffix_node)))" "i-tree" "(search_tree \\"pi\\" i-tree)" "(def pi-tree (build_suffix_tree \\"pi\\"))" "pi-tree" "(build_suffix_tree \\"ppi\\")" "(search_tree \\"ppi\\" pi-tree)" "(is_exact_match (first (search_tree \\"ppi\\" pi-tree)))" "(is_exact_match (first (search_tree \\"ppi\\" pi-tree)) \\"ppi\\")" "(assoc-in (branch_node pi-tree \\"pi\\"\\n           \\"p\\" ) [\:children \\n          \\"p\\" \:children \\n       (subs \\"ppi\\" (count \\"p\\") (count \\"ppi\\"))] \\n          (build_suffix_node))" "(def pi-tree (assoc-in (build_suffix_node) [\:children \\"pi\\"] (build_suffix_node)))" "pi-tree" "(branch_node pi-tree \\"pi\\" \\"p\\")" "(get pi-tree \:children)" "(get-in pi-tree [\:children \\"pi\\"])" "(get-in pi-tree [\:children \\"pi\\" \:children])" "(branch_node pi-tree \\"pi\\" \\"p\\")" "(assoc (build_suffix_node) \:children (get pi-tree \:children))" "(branch_node pi-tree \\"pi\\" \\"p\\")" "(get-in pi-tree [\:children \\"pi\\" \:children])" "(dissoc-in pi-tree [\:children \\"pi\\"])" "pi-tree" "(dissoc pi-tree \\"pi\\")" "(dissoc pi-tree \:children)" "(dissoc pi-tree [\:children \\"pi\\"])" "(dissoc-in pi-tree \\"pi\\")" "(dissoc-in pi-tree \:children \\"pi\\")" "(dissoc-in (assoc-in pi-tree [\:children \\"i\\"] (build_suffix_node)) [\:children \\"pi\\"])" "(assoc-in pi-tree [\:children \\"i\\"] (build_suffix_node))" "(branch_node (assoc-in pi-tree [\:children \\"i\\"] (build_suffix_node)) \\"pi\\" \\"p\\")" "(def pi-tree (assoc-in pi-tree [\:children \\"i\\"] (build_suffix_node)))" "pi-tree" "(get-in pi-tree [\:children \\"pi\\" \:children])" "(dissoc-in pi-tree [\:children \\"pi\\"])" "(assoc (assoc-in (dissoc-in pi-tree [\:children \\"pi\\"]) [\:children \\"p\\"] (build_suffix_node)) \:children {})))" "(assoc (assoc-in (dissoc-in pi-tree [\:children \\"pi\\"]) [\:children \\"p\\"] (build_suffix_node)) \:children {})" "(branch_node pi-tree \\"pi\\" \\"p\\")" "(\#(assoc-in (assoc-in pi-tree [\:children \\"s\\"] (build_suffix_node))\\n                                                              [\:children \\"s\\" \:children (key %)] (val %)) [\\"a\\" (build_suffix_node)])))" "(\#(assoc-in (assoc-in pi-tree [\:children \\"s\\"] (build_suffix_node))\\n                                                              [\:children \\"s\\" \:children (key %)] (val %)) [\\"a\\" (build_suffix_node)])" "[\\"a\\" (build_suffix_node)]" "(hash-map \\"a\\" (build_suffix_node))" "(\#(assoc-in (assoc-in pi-tree [\:children \\"s\\"] (build_suffix_node))\\n                                                              [\:children \\"s\\" \:children (key %)] (val %)) (hash-map \\"a\\" (build_suffix_node)))" "(\#(assoc-in (build_suffix_node) [\:children (key %)] (val %)) (hash-map \\"a\\" (build_suffix_node)))" "(branch_node pi-tree \\"pi\\" \\"p\\")" "(assoc-in pi-tree [\:children \\"p\\" \:children \\"s\\"] (build_suffix_node))" "(branch_node (assoc-in pi-tree [\:children \\"p\\" \:children \\"s\\"] (build_suffix_node)) \\"pi\\" \\"p\\")" "(get-in (assoc-in pi-tree [\:children \\"p\\" \:children \\"s\\"] (build_suffix_node)) [\:children \\"pi\\" \:children])" "(branch_node (assoc-in pi-tree [\:children \\"pi\\" \:children \\"s\\"] (build_suffix_node)) \\"pi\\" \\"p\\")" "(branch_node pi-tree \\"pi\\" \\"p\\")" "(branch_node (assoc-in pi-tree [\:children \\"pi\\" \:children \\"s\\"] (build_suffix_node)) \\"pi\\" \\"p\\")" "(do \#(assoc-in (build_suffix_node) [\:children (key %)] (val %)) (hash-map \\"a\\" (build_suffix_node), \\"b\\" (build_suffix_node)))" "(hash-map \\"a\\" (build_suffix_node), \\"b\\" (build_suffix_node))" "(map \#(assoc-in (build_suffix_node) [\:children (key %)] (val %)) (hash-map \\"a\\" (build_suffix_node), \\"b\\" (build_suffix_node)))" "(branch_node pi-tree \\"pi\\" \\"p\\")" "(assoc-in (assoc-in (build_suffix_node) [\:children \\"a\\"] (build_suffix_node)) [\:children \\"b\\"] (build_suffix_node))" "(assoc-in pi-tree [\:children \\"pi\\" \:children \\"s\\"] (build_suffix_node))" "(assoc-in pi-tree [\:children \\"s\\"] (build_suffix_node))" "(assoc-in (assoc-in pi-tree [\:children \\"s\\"] (build_suffix_node)) [\:children \\"s\\" \:children \\"q\\"] (build_suffix_node))" "(branch_node pi-tree \\"pi\\" \\"p\\")" "(build_suffix_tree \\"theh\\")" "(build_suffix_tree \\"mississippi\\")" "(build_suffix_tree \\"i\\")" "(build_suffix_tree \\"pi\\")" "(build_suffix_tree \\"ppi\\")" "pi-tree" "(search_tree \\"ppi\\" pi-tree)" "(is_exact_match (first (search_tree \\"ppi\\" pi-tree)))" "(is_exact_match (first (search_tree \\"ppi\\" pi-tree)) \\"ppi\\")" "(deeef the-tree (build_suffix_tree \\"the\\"))" "(def the-tree (build_suffix_tree \\"the\\"))" "the-tree" "(search_tree \\"ha\\")" "(search_tree \\"ha\\" the-tree)" "(is_exact_match (first (search_tree \\"ha\\" the-tree)) \\"ha\\")" "(search_tree \\"hee\\n\\" the-tree)" "(is_exact_match (first (search_tree \\"hee\\" the-tree)) \\"hee\\")" "((comp not nil?)(re-find (re-pattern (str \\"^\\" \\"he\\" \\"$\\")) \\"he\\"))" "(is_exact_match (first (search_tree \\"hee\\" the-tree)) \\"hee\\")" "(is_exact_match (first (search_tree \\"ha\\" the-tree)) \\"ha\\")" "(build_suffix_tree \\"the\\")" "(build_suffix_tree \\"theh\\")" "(build_suffix_tree \\"the\\")" "(build_suffix_tree \\"theh\\")" "(build_suffix_tree \\"mississippi\\")" "(build_suffix_tree \\"i\\")" "(build_suffix_tree \\"pi\\")" "(build_suffix_tree \\"ppi\\")" "(branch_node (build_suffix_tree \\"pi\\") \\"pi\\" \\"p\\")" "(assoc-in (branch_node (build_suffix_tree \\"pi\\") \\"pi\\" \\"p\\") [\:children \\"p\\" \:children \\"pi\\"] (build_suffix_node))" "(add_children (assoc-in (build_suffix_node) [\:children \\"p\\"] (build_suffix_node)) \\"p\\" (hash-map \\"a\\" (build_suffix_node), \\"b\\" (build_suffix_node)))" "(count (hash-map \\"a\\" (build_suffix_node), \\"b\\" (build_suffix_node)))" "(assoc-in (assoc-in (build_suffix_node) [\:children \\"p\\"] (build_suffix_node)) [\:children \\"p\\" \:children (key (first (hash-map \\"a\\" (build_suffix_node), \\"b\\" (build_suffix_node))))] (val (first (hash-map \\"a\\" (build_suffix_node), \\"b\\" (build_suffix_node)))))" "(add_children (assoc-in (build_suffix_node) [\:children \\"p\\"] (build_suffix_node)) \\"p\\" (hash-map \\"a\\" (build_suffix_node), \\"b\\" (build_suffix_node)))" "(build_suffix_tree \\"theh\\")" "(build_suffix_tree \\"mississippi\\")" "(build_suffix_tree \\"i\\")" "(build_suffix_tree \\"pi\\")" "(build_suffix_tree \\"ppi\\")" "(branch_node (build_suffix_tree \\"pi\\") \\"i\\" \\"p\\")" "(def pi-tree (build_suffix_tree \\"pi\\"))" "(assoc (get-in pi-tree [\:children \\"pi\\" \:children]) (subs \\"pi\\" (count \\"ppi\\") (count \\"pi\\")) (get pi-tree \\"pi\\"))" "(assoc (get-in pi-tree [\:children \\"pi\\" \:children]) (subs \\"pi\\" (count \\"p\\") (count \\"pi\\")) (get pi-tree \\"pi\\"))" "(get p-tree \\"pi\\")" "(get pi-tree \\"pi\\")" "pi-tree" "(get pi-tree \:children \\"pi\\")" "(get-in pi-tree \:children \\"pi\\")" "(get-in pi-tree [\:children \\"pi\\"])" "(branch_node pi-tree \\"pi\\" \\"p\\")" "(build_suffix_tree \\"i\\")" "(build_suffix_tree \\"pi\\")" "(build_suffix_tree \\"ppi\\")" "(build_suffix_tree \\"ippi\\")" "(build_suffix_tree \\"sippi\\")" "(build_suffix_tree \\"ssippi\\")" "(build_suffix_tree \\"mississippi\\")" "(build_suffix_tree \\"mississippiU\\")" "(select-keys (build_suffix_tree \\"mississippi\\"))" "(get (build_suffix_tree \\"mississippi\\") \:children)" "(keys(get (build_suffix_tree \\"mississippi\\") \:children))" "(println 1 (keys(get (build_suffix_tree \\"mississippi\\") \:children)))" "(clojure.pprint (build_suffix_tree \\"mississippi\\"))" "(def mississippi (build_suffix_tree \\"mississippi\\"))" "(clojure.pprint.PrettyFlush mississippi)" "(clojure.pprint.PrettyFlush (keys mississippi))" "(use 'clojure.pprint)" "(pprint mississippi)" "(defn print-subtree [subtree prefix]\\n  (if (empty? subtree)\\n    \\"\\"\\n    (apply str prefix (first subtree) \\"\\\\n\\"\\n           (map \#(print-subtree %1 (str \\"\\\\t\\" prefix)) (rest subtree)))))\\n \\n(defn print-tree [tree]\\n  (print-subtree tree \\"\\"))" "(print-tree mississippi)" "(def mississippi (build_suffix_tree \\"mississippi\\"))" "(use vijual)" "(draw-tree mississippi)" "(defn mississippi (build_suffix_tree \\"mississippi\\"))" "(def mississippi (build_suffix_tree \\"mississippi\\"))" "(loop-find-children mississippi)" "(loop-find-children (build_suffix_tree \\"ississippi\\"))" "(first (keys (get mississippi \:children))" "(first (keys (get mississippi \:children)))" "(get-in mississippi [\:children \\"mississippi\\"])" "(first (keys (get (get-in mississippi [\:children \\"mississippi\\"]) \:children)))" "(first (keys (get (build_suffix_tree \\"ississippi\\" \:children)))" "(first (keys (get (build_suffix_tree \\"ississippi\\") \:children)))" "(get-in (build_suffix_tree \\"ississippi\\") [\:children \\"s\\"])" "(get mississippi \:children)" "(get-in mississippi [\:children (first (keys (get mississippi \:children)))])" "(build_suffix_tree \\"mississippi mountain \\")" "(build_suffix_tree \\"mississippi \\")" "(clojure.pprint/pprint (build_suffix_tree \\"mississippi \\"))" "(use 'clojure.pprint)" "(pprint (build_suffix_tree \\"mississippi \\"))" "(pprint (build_suffix_tree \\"nick\\"))" "(pprint (build_suffix_tree \\"nickck\\"))"]
eclipse.preferences.version=1
