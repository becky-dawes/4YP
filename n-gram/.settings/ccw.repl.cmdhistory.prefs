cmdhistory=["(max the-map)" "(reduce max the-map)" "(max (map val the-map))" "(reduce max (map val the-map))" "(max-key the-map)" "(max-key val the-map)" "(key (apply max-key val the-map))" "(next-word \\"the\\")" "(next-word \\"the\\" \\"scarecrow\\")" "(find-trio \\"the\\" \\"scarecrow\\")" "(next-word \\"the\\" \\"scarecrow\\")" "(next-word \\"the\\" 1)" "(next-word \\"the \\"scarecrow\\" 2)" "(next-word \\"the\\" 1)" "(next-word \\"the\\" \\"sacrecrow\\" 1)" "(next-word \\"the\\" 2)" "(next-word \\"the\\")" "(next-word \\"the\\" \\"scarecrow\\")" "(next-word \\"a\\")" "(next-word \\"a\\" \\"great\\")" "(p2-letter \\"th\\")" "(next-letter \\"th\\")" "(first (key (first letter-trios)))" "(first letter-trios)" "(next-letter \\"t\\")" "(next-letter \\"th\\")" "(next-letter \\"T\\")" "(letters \\"T\\")" "(next-word \\"THE\\")" "(words \\"THE\\")" "(words \\"the\\")" "(counts-ASCII-1\\"T\\")" "(next-word \\"THE\\")" "(next-letter \\"T\\")" "(next-letter \\"TH\\")" "(next-letter \\"th\\")" "(next-letter \\"Th\\")" "(next-letter \\"he\\")" "(next-letter \\"re\\")" "(next-letter \\"br\\")" "(def file-name (str \\"Wikipedia.txt\\"))" "(def lines (str \\"The quick brown fox jumps over the lazy dog.\\"))" "(next-letter \\"th\\")" "(next-word \\"the\\")" "(next-word \\"the\\" \\"lazy\\")" "(next-word \\"box\\")" "(find-pair \\"the\\")" "(find-pair \\"box\\")" "(max-key val (find-pair \\"box\\"))" "(key (apply max-key val (find-pair \\"box\\")))" "words" "(def lines \\"The quick brown fox jumps over the lazy dog.\\")" "words" "pairs" "trios" "letters" "letter-pairs" "(next-word \\"box\\")" "(p \\"the\\")" "(p \\"the\\" \\"fox\\")" "(p \\"the\\" \\"quick\\")" "(p1-letter \\"t\\")" "(p2-letter \\"th\\")" "(p2-letter \\"he\\")" "(p2-letter \\"qu\\")" "(counts-ASCII-2 \\"th\\")" "(counts-ASCII-1 \\"t\\")" "(p2-letter \\"qu\\")" "(counts-ASCII-2 \\"qu\\")" "(counts-ASCII-1 \\"q\\")" "(p1-letter \\"q\\")" "(p-letter \\"t\\")" "(p-letter \\"TH\\")" "(p-letter \\"THE\\")" "(p-letter 'THEN\\")" "(p-letter \\"THEN\\")" "(p-letter \\"q\\")" "(p-letter \\"qu\\")" "(p-letter \\"the\\")" "(p-letter \\"th\\")" "(p-letter \\"qu\\")" "(g-t-prob \\"the\\")" "(g-t-prob \\"the\\" \\"quick\\")" "(g-t-prob [\\"the\\" \\"quick\\"])" "(g-t-prob [\\"the\\" \\"scarecrow\\"])" "(g-t-prob \\"the\\")" "(g-t-prob [\\"the\\" \\"wizard\\"])" "(g-t-prob \\"the\\")" "(g-t-prob \\"i\\")" "(g-t-prob [\\"i\\" \\"went\\"])" "(p \\"i\\" \\"went\\")" "(p \\"day\\" \\"i\\")" "(g-t-prob [\\"day\\" \\"i\\"])" "(g-t \\"i\\")" "(g-t \\"i\\" 1)" "(g-t \\"went\\" 1)" "(g-t [\\"i\\" \\"went\\"] 2)" "(p \\"i\\")" "(p \\"went\\")" "(p1 \\"i\\")" "(p2 \\"i\\" \\"went\\")" "(float (g-t \\"i\\" 1))" "(float (g-t [\\"i\\" \\"went\\"] 2)" "(float (g-t [\\"i\\" \\"went\\"] 2))" "(float (/ (p2 \\"i\\" \\"went\\") (p1 \\"i\\")))" "(float (/ (p1 \\"i\\") (p2 \\"i\\" \\"went\\")))" "(float (/ (counts-2 [\\"i\\" \\"went\\"]) (counts-1 \\"i\\")))" "(float (/ (counts-2 [\\"i\\" \\"went\\"]) (counts-1 [\\"i\\"])))" "(counts-2 [\\"i\\" \\"went\\"])" "(p \\"i\\" \\"went\\")" "(g-t-prob [\\"i\\" \\"went\\"])" "(next-word \\"a\\")" "(next-word \\"kasjbd\\")" "(next-word \\"asbdasjba\\")" "(pairs)" "pairs" "counts-2" "(g-t-prob \\"a\\")" "(g-t-prob [\\"a\\" \\"lion\\"])" "(next-word (take 1 [\\"the\\" \\"lion\\"]))" "(next-word \\"the\\")" "(take 1 [\\"the\\" \\"lion\\"])" "(take 1 (next-word \\"the\\"))" "(last [\\"the\\" \\"lion\\"])" "(next-word (first [\\"the\\" \\"lion\\"]))" "(get-last-two words)" "(last words)" "(rest words)" "(last (rest words))" "(get-last-two words)" "(first (get-last-two words))" "(str (first (get-last-two words)))" "(last words)" "(next-word (last words))" "(first (last words))" "(get-last-two words)" "(next-word (get-last-two words))" "(predict-text [\\"the\\" \\"scarecrow\\"] 3)" "(butlast (butlast [\\"the\\" \\"scarecrow\\"]))" "(butlast (butlast [\\"the\\" \\"scarecrow\\" \\"said\\"]))" "(get-last-two [\\"the\\" \\"scarecrow\\" \\"said\\"])" "(last [\\"the\\" \\"sacrecrow\\" \\"said\\"])" "(last (butlast [\\"the\\" \\"scarecrow\\" \\"said\\"]))" "(predict-text [\\"the\\" \\"scarecrow\\" \\"said\\"] 3)" "(get-last-two [\\"the\\" \\"sacrecrow\\" \\"said\\"])" "(- 3 1)" "(cons (butlast (butlast [\\"the\\" \\"sacrecrow\\" \\"said\\"])) (get-last-two [\\"the\\" \\"scarecrow\\" \\"said\\"]))" "(cons (butlast (butlast [\\"the\\" \\"sacrecrow\\"])) (get-last-two [\\"the\\" \\"scarecrow\\"]))" "(predict-text [\\"the\\" \\"sacrecrow\\"] 3)" "(predict-text [\\"the\\" \\"sacrecrow\\" \\"said\\"] 3)" "\\"\\"" "(loop-next-words \\"the\\" \\"sacrecrow\\" 2)" "(next-word \\"the\\" \\"scarecrow\\")" "(def next-words (next-word \\"the\\" \\"scarecrow\\"))" "(def last-two (get-last-two next-words))" "last-two" "(loop-next-words \\"the\\" \\"scarecrow\\" 2)" "(loop-next-words \\"the\\" \\"sacrecrow\\" 3)" "(first last-two)" "(first next-words)" "(loop-next-words [\\"the\\" \\"scarecrow\\"])" "(loop-next-words [\\"the\\" \\"scarecrow\\"] 2)" "(loop-next-words \\"the\\" \\"scarecrow\\" 2)" "(loop-next-words \\"the\\" \\"scarecrow\\" 3)" "(loop-next-words \\"the\\" \\"scarecrow\\" 2)" "(loop-next-words \\"the\\" \\"scarecrow\\" 3)" "(predict-text words 4)" "words" "(predict-text [\\"the\\" \\"lion\\" \\"was\\" \\"walking\\" \\"through\\" \\"the\\" \\"forest\\" \\"one\\" \\"day\\"] 5)" "(cons \\"the\\" \\"lion\\")" "(cons \\"the\\" [\\"lion\\"])" "(cons \\"the\\" (cons \\"the\\" [\\"lion\\"]))" "(butlast (butlast words))" "(butlast (butlast [\\"the\\" \\"lion\\" \\"said\\"]))" "(str (butlast [\\"the\\" \\"lion\\"]))" "(butlast [\\"the\\" \\"lion\\"])" "(val (butlast [\\"the\\" \\"lion\\"]))" "(take (count [\\"the\\" \\"lion\\"]) (butlast [\\"the\\" \\"lion\\"]))" "(first (butlast [\\"the\\" \\"lion\\"]))" "words-vector" "words" "(str \\"the\\" \\"lion\\" \\"said\\")" "(reduce \#(str % \\" \\") words)" "(reduce + words)" "(reduce str words)" "(def some-words [\\"the\\" \\"lion\\" \\"went\\" \\"for\\" \\"a\\" \\"walk\\"])" "(reduce str some-words)" "(reduce \#(str % \\" \\") some-words)" "(defn add-space [word] (str word \\" \\"))" "(reduce add-space some-words)" "(\#(str % \\" \\") some-words)" "(clojure.string/join some-words \\" \\")" "(clojure.string/join some-words)" "(reduce \#(str (str % \\" \\")) some-words)" "( \#(str (str % \\" \\")) some-words)" "(str (\#(str % \\" \\") some-words))" "(str some-words)" "(clojure.string/join \#(str % \\" \\") some-words)" "(clojure.string/join (\#(str % \\" \\") some-words))" "(str (first some-words) \\" \\")" "(join-words some-words)" "(def some-words [\\"a\\" \\"lion\\" \\"went\\" \\"for\\" \\"a\\" \\"walk\\"])" "(join-words some-words)" "(str (first some-words) \\" \\")" "(join-words some-words)" "(def first-word (str (first some-words) \\" \\"))" "(str first-word (str (first (rest some-words)) \\" \\"))" "(join-words [\\"a\\" \\"lion\\"])" "(def word (str (first some-words) \\" \\"))" "(def word2 (str word (join-words (rest some-words)))" "(rest some-words)" "(join-words [])" "(join-words some-words)" "(predict-text some-words)" "(predict-text some-words 3))" "(predict-text some-words 3)" "(join-words (butlast (butlast some-words)))" "(loop-next-words (first (get-last-two some-words)) (second (get-last-two some-words)) 3)" "(loop-next-words \\"a\\" \\"lion\\" 3)" "(def some-words [\\"Dorothy\\" \\"saw\\" \\"a\\" \\"lion\\"])" "(predict-text some-words 3)" "(predict-text words 5)" "(predict-text words-vector 5)" "(join-words words-vector 5)" "(join-words words-vector)" "(join-words (take 20 words-vector))" "(predict-text (take 100 words-vector) 20)" "(def unknown \\"<UNK>\\")" "(type words)" "(reduce replace words)" "(clojure.contrib.seq-utils/find-first \\"the\\" words-vector)" "(first (filter \#(\= % \\"the\\") words-vector)" "(filter \#(\= % \\"the\\") words-vector)" "(filter (\= \\"the\\") words-vector)" "(defn find-first\\n         [f coll]\\n         (first (filter f coll)))" "(find-first \#(\= % \\"the\\") words-vector)" "(replace \\"the\\" words-vector)" "(clojure.string/replace-first words-vector \\"the\\" unknown)" "(clojure.string/replace-first words \\"the\\" unknown)" "(clojure.string/replace-first words \\"cabbages\\" unknown)" "(def words (makeWords words)" "(def words (makeWords words))" "words" "(def words-vector (clojure.string/replace-first words-vector \\"cabbages\\" unknown))" "(makeWords words-vector)" "words-vector" "(def replaced-lines (clojure.string/replace-first lines \\"cabbages\\" unknown))" "replaced-lines" "(def formattedText \\"Text with all punctuation (except apostrophes) removed and converted to lower case\\" \\n  (clojure.string/lower-case (clojure.string/replace replaced-lines \#\\"[\\\\p{P}&&[^'][\\\\n]]\\" \\"\\")))" "words-vector" "(distinct lines)" "(distinct words)" "(distinct words-vector)" "unique-words" "words-vector" "unique-words" "replaced-lines" "(def some-words [\\"a\\" \\"walk\\" \\"park\\" \\"a\\" \\"in\\" \\"the\\" \\"walk\\"])" "(replace-first-word some-words (distinct some-words))" "(< 0 (count (distinct some-words)))" "(clojure.string/replace-first (first some-words) some-words unknown)" "(clojure.string/replace-first some-words (first some-words) unknown)" "(def some-words \\"a walk park a in the walk\\")" "(def some-text some-words)" "some-text" "(def some-words (split-words some-text))" "(replace-first-word some-text (distinct some-words))" "(clojure.string/replace-first some-text (first some-words) unknown)" "(def some-distinct-words (distinct some-words))" "some-distinct-words" "(clojure.string/replace-first (clojure.string/replace-first some-text (second some-words) unknown) (first some-words) unknown)" "(replace-first-word some-text some-distinct-words)" "words-vector" "(find-pair \\"the\\")" "(def some-text \\"a walk in the park a the in new\\")" "(def some-words (split-words some-text))" "(def some-distinct (distinct some-words))" "(replace-first-word some-text some-distinct)" "(str \#\\"[\\\\p{P}&&[^'][\\\\n]][ ]\\" (first some-distinct) \#\\"[\\\\p{P}&&[^'][\\\\n]][ ]\\")" "(def match (str \#\\"[\\\\p{P}&&[^'][\\\\n]][ ]\\" (first some-distinct) \#\\"[\\\\p{P}&&[^'][\\\\n]][ ]\\"))" "(clojure.string/replace some-text match unknown)" "(re-matches match some-text)" "(def match (str \\"[\\\\p{P}&&[^'][\\\\n]][ ]\\" (first some-distinct) \\"[\\\\p{P}&&[^'][\\\\n]][ ]\\"))" "(str \\"[\\\\p{P}&&[^'][\\\\n]][ ]\\")" "(re-matches \#(\\"[ ]\\" match) some-text)" "(re-pattern \\"[\\\\p{P}&&[^'][\\\\n]]\\" match)" "(re-pattern match)" "(replace-first-word some-text some-distinct)" "words-vector" "pairs" "(predict-text [\\"a\\" \\"lion\\"] 2)" "(get-count counts-1 \\"a\\")" "(counts-1 \\"a\\")" "(counts-1 [\\"a\\"])" "(predict-text [\\"a\\" \\"lion\\"] 2)" "(predict-text [\\"a\\" \\"skunk\\"] 2)" "(predict-text [\\"a\\" \\"skunk\\"] 10)" "(predict-text [\\"said\\" \\"skunk\\"] 10)" "(next-word \\"the\\" \\"lion\\")" "(next-word \\"the\\")" "(next-letter \\"th\\")" "(next-letter \\"a\\")" "(next-letter \\"a \\")" "(predict-text \\"the scarecrow and\\" 4)" "(get-last-two \\"the scarecrow and\\")" "(predict-text [\\"the\\" \\"scarecrow\\" \\"and\\")" "(predict-text [\\"the\\" \\"scarecrow\\" \\"and\\"])" "(predict-text [\\"the\\" \\"scarecrow\\" \\"and\\"] 2)" "(predict-text [\\"the\\" \\"scarecrow\\" \\"and\\"] 6)" "(predict-text [\\"the\\" \\"scarecrow\\" \\"and\\" \\"the\\" \\"lion\\"] 6)" "(predict-text [\\"the\\" \\"dog\\" \\"went\\"] 6)" "(predict-text [\\"fish\\"] 3)" "(predict-text [\\"fish\\" \\"and\\"] 3)" "(predict-text [\\"fish\\" \\"and\\" \\"chips\\"] 3)" "(next-word [\\"the\\"])" "(next-word \\"the\\")" "(next-word \\"the\\" \\"scarecrow\\")" "(predict-text [\\"the scarecrow\\"] 5)" "(predict-text \\"the scarecrow\\" 5)" "(predict-text [\\"the\\" \\"scarecrow\\"] 5)" "(predict-text [\\"the\\" \\"scarecrow\\"] 7)" "(predict-text [\\"the\\" \\"scarecrow\\"] 11)" "(predict-text [\\"the\\" \\"laksdjalskdj\\"] 11)" "(type unique-words)" "(type words-vector)" "(type letters)" "(ns-name *ns*)" "(ns-interns *ns*)" "(ns-map *ns*)" "(ns-name *ns*)" "lein new app the-divine-cheese-code" "lein run" "lein self-install" "lein run" "lines" "N" "all-ns" "(reduce ns-name all-ns)" "ns-map" "(n-gram.words.word-probs/p \\"the\\")" "(n-gram.words.word-probs/p \\"the\\" \\"wizard\\")" "(n-gram.words.word-predictor/predict-text \\"the wizard went for a walk\\" 5)" "(n-gram.words.word-predictor/predict-text [\\"the\\" \\"wizard\\" \\"went\\" \\"for\\" \\"a\\" \\"walk\\"] 5)" "(n-gram.words.word-predictor/next-word \\"the\\")" "(last (n-gram.words.word-predictor/next-word \\"the\\"))" "(n-gram.words.word-predictor/predict-text [\\"the\\" \\"wizard\\" \\"and\\" \\"the\\" \\"dog\\"] 5)" "(n-gram.words.word-predictor/next-word \\"the\\" \\"dog\\")" "(n-gram.words.word-predictor/predict-text [\\"the\\" \\"wizard\\" \\"went\\" \\"on\\" \\"holiday\\"] 5)" "(n-gram.words.word-predictor/next-word \\"on\\" \\"holiday\\")" "(n-gram.words.word-predictor/loop-next-words \\"holiday\\" \\"and\\" 1)" "(n-gram.words/word-predictor/predict-text [\\"the\\" \\"wizard\\" \\"went\\" \\"for\\" \\"a\\" \\"walk\\"] 5)" "(n-gram.words.word-predictor/predict-text [\\"the\\" \\"wizard\\" \\"went\\" \\"for\\" \\"a\\" \\"walk\\"] 5)" "(n-gram.words.word-predictor/predict-text [\\"the\\" \\"dog\\" \\"ate\\" \\"the\\" \\"lion\\"] 6)" "(n-gram.words.word-predictor/predict-text n-gram.words.file-reader/words 6)" "(n-gram.words.word-predictor/predict-text (take 20 n-gram.words.file-reader/words) 6)" "(take 20 n-gram.words.file-reader/words)" "n-gram.words.file-reader/words" "(str \\" \\" \\"abc\\" \\" \\")" "(n-gram.words.word-predictor/predict-text [\\"the\\" \\"wizard\\" \\"went\\" \\"for\\" \\"a\\" \\"walk\\"] 5)" "(n-gram.words.word-predictor/next-word \\"my\\" \\"is\\")" "(n-gram.words.word-predictor/next-word \\n  \\"is\\")" "(last (key (apply max-key val (find-trio-memo \\"my\\" \\"is\\"))))" "(last (key (apply max-key val (find-trio-memo \\"is\\" \\"is\\"))))" "(n-gram.words.word-predictor/predict-text [\\"the\\" \\"wizard\\" \\"went\\" \\"for\\" \\"a\\"] 5)" "(last (key (apply max-key val (find-pair-memo \\"a\\"))))" "(last (key (apply max-key val (find-trio-memo \\"a\\" \\"walk\\"))))" "(def context [\\"the\\" \\"wizard\\" \\"went\\" \\"for\\" \\"a\\" \\"walk\\"])" "context" "(get-last-two context)" "(next-word (get-last-two context))" "(next-word (last context) \\"my\\")" "(next-word \\"the\\" \\"walk\\")" "(next-word \\"the\\" \\"air\\")" "(def context [\\"I\\" \\"love\\" \\"coconuts\\"])" "(predict-text contect 2)" "(predict-text context 2)" "(def context [\\"I\\" \\"love\\" \\"coconuts\\"])" "(predict-text context 2)" "(def context [\\"dorothy\\" \\"said\\"])" "(predict-text context 2)" "(find-pair \\"said\\")" "(apply max-key val (find-pair \\"said\\"))" "(key (apply max-key val (find-pair \\"said\\")))" "(last (key (apply max-key val (find-pair \\"said\\"))))" "(next-word \\"said\\")" "(loop-next-words-memo \\"dorothy\\" \\"said\\" 2)" "(loop-next-words \\"said\\" \\"the\\" 1)" "(predict-text [\\"dorothy\\" \\"said\\"] 2)" "(next-word \\"dorothy\\" \\"said\\")" "(loop-next-words \\"dorothy\\" \\"said\\" 2)" "(predict-text [\\"dorothy\\" \\"said\\"] 2)" "(next-word \\"dorothy\\" \\"said\\")" "(loop-next-words \\"dorothy\\" \\"said\\" 2)" "(predict-text [\\"dorothy\\" \\"said\\"] 2)" "(loop-next-words \\"dorothy\\" \\"said\\" 2)" "(join-words [\\"dorothy\\" \\"said\\"])" "(def the-context [\\"dorothy\\" \\"said\\"])" "(last the-context)" "(str (join-words the-context) (join-words (loop-next-words (last the-context) (next-word (get-last-two the-context) 2)))" "(def the-last-two (get-last-two the-context))" "(def the-last (last the-context))" "(def the-prediction (loop-next-words the-last the-last-two 2))" "(str (join-words the-ontext) (join-words the-prediction))" "(str (join-words the-context) (join-words the-prediction))" "(join-words the-context)" "the-prediction" "(loop-next-words the-last the-last-two 2)" "(def the-next-word (next-word the-last-two))" "(def the-prediction (loop-next-words the-last the-next-word 2))" "(str (join-words the-context) (join-words the-prediction))" "the-prediction" "the-next-word" "the-last" "(next-word \\"dorothy\\" \\"said\\")" "the-last-two" "(predict-text [\\"dorothy\\" \\"said\\"] 2)" "(predict-text [\\"dorothy\\" \\"said\\"] 5)" "(predict-text [\\"dorothy\\" \\"said\\"] 10)" "(predict-text [\\"dorothy\\" \\"said\\" \\"I\\" \\"love\\" \\"coconuts\\"] 10)" "(predict-text [\\"dorothy\\" \\"said\\" \\"I\\" \\"love\\" \\"coconuts\\"] 5)" "cumsum-counts-of-counts-1" "n-r-1" "counts-of-counts-1" "(key counts-of-counts-1)" "(key (first counts-of-counts-1))" "counts-1" "(type n-r-1)" "(type counts-of-counts-1)" "(type cumsum-counts-of-counts-1)" "n-r-1" "counts-of-counts-1" "(map key counts-of-counts-1)" "counts-1" "(predict-text [\\"I\\" \\"like\\" \\"starwberries\\"] 5)" "(predict-text [\\"dorothy\\" \\"said\\"] 5)" "(predict-text [\\"dorothy\\" \\"said\\"] 2)" "(predict-text-memo [\\"dorothy\\" \\"said\\"] 2)" "(predict-text-memo [\\"dorothy\\" \\"said\\"] 3)" "(predict-text-memo [\\"dorothy\\" \\"said\\"] 4)" "(predict-text-memo [\\"dorothy\\" \\"said\\"] 5)" "(predict-text-memo [\\"dorothy\\" \\"said\\"] 6)" "(type (cons \\"the\\" \\"apple\\"))" "(length (loop-next-words \\"the\\" \\"dog\\" 2))" "(count (loop-next-words \\"the\\" \\"dog\\" 2))" "(loop-next-words \\"the\\" \\"dog\\" 2)" "(predict-text [\\"the\\" \\"dog\\"] 2)" "(loop-next-words \\"dog\\" \\"in\\" 0)" "(type words-vector)" "(type words)" "(type counts-1)" "n-r-counts-keys-1" "(n-r-counts-keys-1 127)" "(n-r-counts-keys-1 97)" "(resolve (symbol (str \\"n-r-counts-keys-\\" n))" "(resolve (symbol (str \\"n-r-counts-keys-\\" n)))" "(resolve (symbol (str \\"n-r-counts-keys-\\" 1)))" "n-r-counts-keys-1" "(resolve (symbol (str \\"n-r-counts-keys-\\" 1)))" "(def (symbol (str \\"new-var\\" 1)) 1)" "(def ~(symbol (str \\"new-var\\" 1)) 1)" "`(def ~(symbol (str \\"new-var\\" 1)) 1)" "(do `(def ~(symbol (str \\"new-var\\" 1)) 1))" "(resolve `(def ~(symbol (str \\"new-var\\" 1)) 1))" "(defmacro generate-variable [name value]\\n  ('do `(def ~(symbol (str name)) value)))" "(generate-variable \\"new-var\\" 1)" "new-var" "(defmacro generate-variable [name value]\\n  ('do `(def ~(symbol name) value)))" "(generate-variable \\"new-var\\" 1)" "(defmacro generate-variable [name value]\\n  (do `(def ~(symbol name) value)))" "(generate-variable \\"new-var\\" 1)" "(defmacro generate-variable [name value]\\n  (do `(def ~(symbol name) \\n         (partial ~name ~@value))))" "(generate-variable \\"new-var\\" 1)" "(generate-variable \\"new-var\\" [1])" "new-var" "(resolve new-var)" "(defmacro generate-variable [name value]\\n  (do `(def ~(symbol name) \\n         ~@value)))" "(generate-variable \\"new-var\\" 1)" "(generate-variable \\"new-var\\" [1])" "new-var" "(generate-variable \\"string-var\\" \\"abcd\\")" "(generate-variable \\"string-var\\" [\\"abcd\\"])" "string-var" "(generate-variable \\"new-vector\\" [1 2 3 4])" "(generate-variable \\"new-vector\\" [[1 2 3 4]])" "new-vector" "(defmacro generate-variable \\"Generates a variable with the given name and value\\" [name value]\\n  (let [new-value [value]]\\n     (do `(def ~(symbol name) \\n            ~@new-value))))" "(generate-variable \\"new-var\\" 1)" "new-var" "(generate-variable \\"string-var\\" \\"abcd\\")" "string-var" "(generate-variable \\"new-vector\\" [1 2 3 4])" "new-var" "new-vector" "(words-vector 0)" "(str \\"interpolation-block-\\" 1)" "(subvec words-vector 0 20)" "(subvec raw-words-vector 0 20)" "(generate-variable (str \\"interpolation-block-\\" 1) (subvec raw-words-vector 0 20))" "(generate-variable \\"interpolation-block-1\\" (subvec raw-words-vector 0 20))" "interpolation-block-1" "(str \\"int\\" 1)" "(generate-variable (str \\"int\\" 1) \\"a\\")" "(type \\"int\\")" "(type (str \\"int\\"))" "(type (str \\"int\\" 1))" "(split-text-into-blocks raw-words-vector 2)" "interpolation-block-1" "(loop-block-creator raw-words-vector 0 20 \\"block-\\" 2)" "block-1" "block-2" "interpolation-block-2" "(generate-variable \\"block1\\" (subvec raw-words-vector 0 20))" "block1" "(do (generate-variable \\"block1\\" (subvec raw-words-vector 0 20)))" "block1" "(do (generate-variable \\"block1\\" (subvec raw-words-vector 0 20))\\n  (loop-block-creator raw-words-vector 20 20 \\"block\\" 0))" "block1" "(do (generate-variable \\"block2\\" (subvec raw-words-vector 0 20))\\n  (loop-block-creator raw-words-vector 20 20 \\"block\\" 1))" "block2" "block1" "(do (generate-variable \\"block2\\" (subvec raw-words-vector 0 20))\\n  (loop-block-creator raw-words-vector 20 20 \\"block\\" 3))" "block1" "block2" "block3" "(> 2 0)" "(generate-variable \\"var1\\" 1)" "(defn new-func [var-name var-val] (generate-variable var-name var-val))" "(defn new-func [v-name var-val] (generate-variable v-name var-val))" "(new-func \\"vv\\" 1)" "(defn new-func [v-name var-val] (generate-variable (var-get v-name) var-val))" "(def new-var-name \\"the-name\\")" "(generate-variable new-var-name 1)" "(generate-variable (var-get new-var-name) 1)" "(var-get new-var-name)" "(generate-variable (resolve new-var-name) 1)" "(generate-variable (resolve (symbol new-var-name)) 1)" "(generate-variable (var-get (resolve (symbol new-var-name))) 1)" "(symbol new-var-name)" "(def new-var-name \\"the-var-name\\")" "(symbol new-var-name)" "(resolve (symbol new-var-name))" "(var-get (resolve (symbol new-var-name)))" "(var-get new-var-name)" "(resolve new-var-name)" "(var-get (symbol new-var-name))" "(generate-variable (symbol new-var-name) 1)" "(generate-variable (str (symbol new-var-name)) 1)" "(symbol new-var-name)" "(str (symbol new-var-name))" "(type (str (symbol new-var-name)))" "(type (symbol new-var-name))" "(generate-variable (str (symbol new-var-name)) 1)" "new-var-name" "the-var-name" "new-var-name" "(str new-var-name)" "(generate-variable (str new-var-name) 1)" "(type new-var-name)" "(resolve (symbol new-var-name))" "(resolve (str (symbol new-var-name)))" "(resolve new-var-name)" "(generate-variable \\"new-var\\" 1)" "new-var" "(def new-var-name \\"the-var-name\\")" "(generate-variable new-var-name 1)" "new-var-name" "(generate-variable \\"new-var\\" 1)" "new-var" "(def new-var-name \\"the-var-name\\")" "(generate-variable new-var-name 1)" "(type new-var-name)" "(def new-var-name \\"the-var-name\\")" "~(symbol new-var-name)" "(~(symbol new-var-name))" "(generate-variable \\"new-var\\" 1)" "new-var" "(def new-var-name \\"new-var2\\")" "(generate-variable new-var-name 1)" "(def new-var-name \\"new-var2\\")" "(var-get (resolve (symbol new-var-name)))" "(var-get (symbol new-var-name))" "(val (symbol new-var-name))" "(eval `(new-var-name))" "(defn create-var\\n  ;; I used clojure.lang.Var/intern in the original answer,\\n  ;; but as Stuart Sierra has pointed out in a comment,\\n  ;; a Clojure built-in is available to accomplish the same\\n  ;; thing\\n  ([sym] (intern *ns* sym))\\n  ([sym val] (intern *ns* sym val)))" "(create-var 'new-var2 1)" "(str new-var-name)" "'(str new-var-name)" "'((str new-var-name))" "'(~(str new-var-name))" "'(`(str new-var-name))" "'(`~\\n    (str new-var-name))" "'(`(~\\n     (str new-var-name)))" "(do `(generate-variable new-var-name 1))" "(quote new-var-name)" "(quote (symbol new-var-name))" "(\#'new-var-name)" "(def a-num 1)" "(\#'a-num)" "(@new-var-name)" "'(~@new-var-name)" "'(new-var-name ~@new-var-name)" "(def x 5)" "(def lst '(a b c))" "`(fred x ~x lst ~@lst 7 8 \:nine)" "`(~@new-var-name)" "(str `(~@new-var-name))" "(str (first (str `(~@new-var-name))) (second (str `(~@new-var-name))))" "(str (first  `(~@new-var-name)) (second  `(~@new-var-name)))" "(clojure.string/join  `(~@new-var-name))" "(generate-variable \\"var1\\" 1)" "var1" "(def var2-name \\"var2\\")" "(generate-variable (clojure.string/join `(~@var2-name)) 2)" "(clojure.string/join `(~@var2-name))" "(generate-variable `(~@var2-name) 2)" "(generate-variable '(clojure.string/join `(~@var2-name)) 2)" "(generate-variable '`(~@var2-name) 2)" "(type (clojure.string/join `(~@var2-name)))" "'(clojure.string/join `(~@var2-name))" "(generate-variable (clojure.string/join `(~@var2-name)) 2)" "interpolation-block-1" "interpolation-block-2" "(last interpolation-block-1)" "(first interpolation-block-2)" "(def a-vector [1 2 3 4 5 6])" "(subvec a-vector 0 3)" "(subvec a-vector 3 4)" "(first interpolation-block-2)" "(p-ML \\"you\\" [\\"are\\"])" "(p-ML \\"because\\" [\\"you\\"])" "(p-ML \\"because\\" [\\"you\\" \\"are\\"])" "(p \\"because\\" \\"you\\")" "(p \\"because\\" \\"you\\" \\"are\\")" "(p-ML \\"because\\" \\"you\\")" "(lambda \\"because\\" \\"you\\")" "(p-interp \\"because\\" [\\"you\\"])" "(p-interp \\"because\\" [\\"you\\" \\"are\\"])" "(reduce + a-vector)" "a-vector" "(\#((/ (+ % 1) 2)) a-vector)" "(map \#((/ (+ % 1) 2)) a-vector)" "(map \#((/ (+ % 1) 2) a-vector))" "(\#(/ (+ % 1) 2) a-vector)" "\#((/ (+ % 1) 2) a-vector)" "(eval \#((/ (+ % 1) 2) a-vector))" "(K 1)" "(sum [1 2 3 4])" "\#((/ (+ % alpha) alpha) counts-1))" "\#((/ (+ % alpha) alpha) counts-1)" "\#((/ (+ % 1) 1) counts-1)" "(sum \#((/ (+ % 1) 1) counts-1))" "(type \#((/ (+ % 1) 1) counts-1))" "(vector \#((/ (+ % 1) 1) counts-1))" "(sum (vector \#((/ (+ % 1) 1) counts-1)))" "(K 1)" "counts-1" "(key (first counts-1))" "(val (first counts-1))" "(K 1)" "\#((/ (* 1 (+ (val %) 1)) (val %)) counts-1)" "(sum \#((/ (* 1 (+ (val %) 1)) (val %)) counts-1))" "(sum (vector \#((/ (* 1 (+ (val %) 1)) (val %)) counts-1)))" "(type (sum (vector \#((/ (* 1 (+ (val %) 1)) (val %)) counts-1))))" "(eval (sum (vector \#((/ (* 1 (+ (val %) 1)) (val %)) counts-1))))" "(+ 1 (sum (vector \#((/ (* 1 (+ (val %) 1)) (val %)) counts-1))))" "(lazy-seq [1 2 3])" "(lazy-seq (* 1 [1 2 3]))" "(cumsum [1 2 3])" "(map \#(if (\= (first (key %)) w1) \\n                                            (if (\= (second (key %)) w2) (val %) 0.0) 0.0) counts-3)" "(map \#(if (\= (first (key %)) \\"the\\") \\n        (if (\= (second (key %)) \\"scarerow\\") (val %) 0.0) 0.0) counts-3)" "(K 1)" "(\#(/ (* 1 (+ (val %) 1)) (val %)) counts-1)" "(K 1)" "\#(/ (+ (val %) 1) 1) counts-1" "counts-1" "\#(/ (+ (val %) 1) 1) counts-1" "(\#(/ (+ (val %) 1) 1) counts-1)" "(reduce + \#(val %) counts-1)" "(def select-values (comp vals select-keys))" "(select-values counts-1)" "(vals counts-1)" "(K 1)" "\#(/ (+ % alpha) alpha) (vals counts-1)" "counts-1" "(vals counts1)" "(vals counts-1)" "(\#(/ (+ % alpha) alpha) (vals counts-1))" "(\#(/ (+ % 1) 1) (vals counts-1))" "(first (vals counts-1))" "(+ 1 (first (vals counts-1)))" "(/(+ 1 (first (vals counts-1)))  1)" "(/(+ 1 (first (vals counts-1)))  2)" "(K 1)" "(vector \#(/ (+ % 1) 1) (vals counts-1))" "(last (vector \#(/ (+ % 1) 1) (vals counts-1)))" "(last  \#(/ (+ % 1) 1) (vals counts-1))" "( \#(/ (+ % 1) 1) (vals counts-1))" "(def counts-1-vals (vals counts-1))" "( \#(/ (+ % 1) 1) counts-1-vals)" "(type counts-1-vals)" "(first counts-1-vals)" "(type (first counts-1-vals))" "(+ 1 (first counts-1-vals))" "(vector \#(/ (+ % 1) 1) counts-1-vals)" "(first (vector \#(/ (+ % 1) 1) counts-1-vals))" "(second (vector \#(/ (+ % 1) 1) counts-1-vals))" "(first  \#(/ (+ % 1) 1) counts-1-vals)" "(first  (\#(/ (+ % 1) 1) counts-1-vals))" "(vector  (map \#(/ (+ % 1) 1) counts-1-vals))" "(last(vector  (map \#(/ (+ % 1) 1) counts-1-vals)))" "(last (vector  (map \#(/ (+ % 1) 1) counts-1-vals)))" "counts-1-vals" "(sum (vector  (map \#(/ (+ % 1) 1) counts-1-vals)))" "(sum   (map \#(/ (+ % 1) 1) counts-1-vals))" "(K 1)" "(take 20 (iterate inc 0))" "(take (- 20 2) (iterate inc 2))" "find-optimum-u" "find-optimum-u-memo" "(find-optimum-u-memo)" "find-optimum-u" "(find-optimum-u initial-alpha)" "find-optimum-u" "(find-optimum-u initial-alpha)" "(def u-0 (find-all-u-memo initial-alpha))" "u-0" "(def u-0 (find-all-u-memo initial-alpha))" "(def alpha-1 (alpha-MP-memo u-0))" "(zipmap (vals counts-1) (map \#(+ 1 %) (keys counts-1)))" "(zipmap (keys counts-1) (map \#(+ 1 %) (vals counts-1)))" "(def text [\\"the\\" \\"cat\\" \\"sat\\" \\"on\\" \\"the\\" \\"mat\\"])" "(def words (make-words text))" "(find-optimum-u)" "(find-optimum-u initial-alpha)" "(find-optimum-u)" "(/ 8 3)" "(float (/ 8 3))" "(with-precision 1 (float (/ 8 3)))" "(with-precision 2 (float (/ 8 3)))" "(\= 1 1.000000000001)" "(with-precision 1 (\= 1 1.000000001))" "(with-precision 1 (\= 1 1.1))" "(with-precision 2 (\= 1 1.1))" "(with-precision 10 (\= 1 1.1))" "(with-precision 1 (1.111))" "(with-precision 1 (/ 1.111 1))" "(with-precision 2 (/ 1.111 1))" "(with-precision 3 (/ 1.111 1))" "(with-precision 10 (/ 1.111 1))" "(with-precision 0 (/ 1.111 1))" "(with-precision 1 (/ 1.111M 1))" "(with-precision 10 (/ 1.111M 1))" "(with-precision 100 (/ 1.111M 1))" "(with-precision 2 (/ 1.111M 1))" "(with-precision 3 (/ 1.111M 1))" "(float 1M)" "(find-optimum-u)" "(def opt-u (find-optimum-u-memo))" "(def opt-alpha (alpha-MP-memo opt-u))" "opt-alpha" "(def opt-m (find-all-m-memo opt-alpha opt-u))" "(P \\"one\\" \\"day\\" opt-alpha opt-m)" "counts-1" "(def opt-u (find-optimum-u))" "(def opt-alpha (alpha-MP-memo opt-u))" "(def opt-m (find-all-m-memo opt-alpha opt-u))" "(P \\"once\\" \\"upon\\" opt-alpha opt-m)" "(counts-2 [\\"once\\" \\"upon\\"])" "counts-2" "(counts-2 [\\"once\\" \\"upon\\"])" "(P \\"once\\" \\"upon\\" opt-alpha opt-m)" "(counts-1 \\"upon\\")" "counts-1" "(P \\"once\\" \\"upon\\" opt-alpha opt-m)" "(counts-1 [\\"upon\\"])" "(find-m-i \\"once\\" opt-m)" "(find-m-i [\\"once\\"] opt-m)" "(P \\"once\\" \\"upon\\" opt-alpha opt-m)" "(bigdec 3.0001)" "(with-precision 1 (bigdec 3.0001))" "(with-precision 1 (\= (bigdec 3.0001) (bigdec 3)))" "(with-precision 1 (\= (format %.1f 3.0001) (format %.1f 3)))" "(with-precision 1 (\= (format \\"%.1f\\" 3.0001) (format \\"%.1f\\" 3)))" "(with-precision 1 (\= (format \\"%.2f\\" 3.0001) (format \\"%.2f\\" 3)))" "(defn equal [num1 num2 accuracy]\\n  (letfn [(bignum [num]\\n            (.setScale (BigDecimal. num)\\n                       accuracy\\n                       BigDecimal/ROUND_DOWN))]\\n    (\= 0 (.compareTo (bignum num1) (bignum num2)))))" "(equal 3.0001 3 1)" "(equal 3.0001 3 2)" "(equal 3.0001 3 3)" "(equal 3.0001 3 4)" "(def u-0 (find-optimum-u-memo))" "(def u (find-optimum-u-memo))" "(def alpha (alpha-MP-memo u))" "(def m (find-all-m-memo alpha))" "(def m (find-all-m-memo alpha u))" "(P-memo \\"once\\" \\"upon\\" alpha m)" "(P-memo \\"once\\" \\"the\\" alpha m)" "(def u (find-optimum-u-memo))" "(def alpha (alpha-MP-memo u))" "(def m (find-all-m-memo alpha u))" "(perplexity alpha m)" "(P-memo \\"once\\" \\"the\\" alpha m)" "(f-i-j 0 0)" "(f-i-j 0 1)" "(P \\"once\\" \\"the\\" alpha m)" "(def the-F-i-j (get-count counts-2 [\\"once\\" \\"the\\"]))" "(def the-F-j (get-count counts-1 [\\"the\\"]))" "(f-i-j the-F-i-j the-F-j)" "the-F-j" "words" "the-F-i-j" "(perplexity)" "alpha-optimum" "m-optimum" "counts-1" "words" "counts-1" "u-optimum" "(K alpha-optimum)" "(G \\"into\\")" "(G-i \\"into\\")" "G-i \\"the\\")" "(G-i \\"the\\")" "(G-i \\"a\\")" "(H-i \\"the\\")" "(H-i \\"a\\")" "(V-i \\"a\\")" "(F-w2-given-w1 \\"the\\")" "(V-i \\"the\\" (F-w2-given-w1 \\"the\\"))" "(V-i \\"a\\" (F-w2-given-w1 \\"a\\"))" "(V-i \\"dorothy\\" (F-w2-given-w1 \\"dorothy\\"))" "(vals (F-w2-given-w1 \\"the\\"))" "(sum (vals (F-w2-given-w1 \\"the\\")))" "(sum (vals (F-w2-given-w1 \\"dorothy\\")))" "u-optimum" "(def F-the (f-w2-w1 \\"the\\"))" "(def F-the (F-w2-given-w1 \\"the\\"))" "(def F-dorothy (F-w2-given-w1 \\"dorothy\\"))" "F-the" "(V-i \\"the\\" (vals F-the))" "(V-i \\"dorothy\\" (vals F-dorothy))" "(sum (map \#(if (\= 0 %) 0 1) (vals F-the)))" "(sum (map \#(if (\= 0 %) 0 1) (vals F-dorothy)))" "(count counts-1)" "(map \#(if (\= 0 %) 0 1) (vals F-dorothy))" "(count counts-2)" "(count counts-1)" "(vals F-the)" "u-optimum" "(F-w2-given-w1 \\"the\\")" "(vals (F-w2-given-w1 \\"the\\"))" "(map \#(if (\= 0 %) 0 1)(vals (F-w2-given-w1 \\"the\\")))" "(sum (map \#(if (\= 0 %) 0 1)(vals (F-w2-given-w1 \\"the\\"))))" "(sum (map \#(if (\= 0 %) 0 1)(vals (F-w2-given-w1 \\"dorothy\\"))))" "(V-i (vals (F-w2-given-w1 \\"the\\")))" "(V-i (vals (F-w2-given-w1 \\"dorothy\\")))" "(find-optimum-u)" "(K 1)" "(java.lang.Math/log 1)" "(java.lang.Math/log 2)" "(java.lang.Math/log 0)" "counts-1" "(vals counts-1)" "(java.lang.Math/log -1)" "(java.lang.Math/log 0.1)" "(map \#(Math/log (/ (+ % 20) 20)) (vals counts-1))" "(sum (map \#(Math/log (/ (+ % 20) 20)) (vals counts-1)))" "(find-optimum-u)" "(n-gram.words.hierarchical-dirichlet/find-optimum-u)" "(map char (concat (range 1 125) ))" "(map char (concat 32 (range 49 59) (range 65 91) (range 97 123)  ))" "(map char (concat (range 32 32 )(range 49 59) (range 65 91) (range 97 123)  ))" "(map char (concat (range 32 33 )(range 48 58) (range 65 91) (range 97 123)  ))" "(map char (concat (range 32 33 )(range 48 58) (range 97 123)  ))" "(first  (map char (concat (range 32 33 )(range 48 58) (range 97 123)  )))" "(second (map char (concat (range 32 33 )(range 48 58) (range 97 123)  )))" "(take 2 (map char (concat (range 32 33 )(range 48 58) (range 97 123)  )))" "(str (take 2 (map char (concat (range 32 33 )(range 48 58) (range 97 123)  ))))" "(str (first (take 2 (map char (concat (range 32 33 )(range 48 58) (range 97 123)  )))))  (second (take 2 (map char (concat (range 32 33 )(range 48 58) (range 97 123)  ))))" "letter-pairs" "(nth 1 letter-pairs)" "(nth 3 (map char (concat (range 32 33 )(range 48 58) (range 97 123)  )))" "(map char (concat (range 32 33 )(range 48 58) (range 97 123)  ))" "(def all-letters (map char (concat (range 32 33 )(range 48 58) (range 97 123)  )))" "(nth 3 all-letters)" "(nth all-letters 3)" "(nth [1 2 3] 1))" "(nth [1 2 3] 1)" "(defn make-the-letters [the-letters group-length current-index]\\n  (let [no-of-letters (count the-letters)] (if (> group-length 0) (if (< current-index no-of-letters) (cons (nth the-letters current-index) (make-the-letters the-letters (dec group-length) 00))\\n                                                                    (cons (nth the-letters (inc current-index)) (make-the-letters the-letters (dec group-length) 0))))))" "(trampoline\\n  (make-the-letters [\\"a\\" \\"b\\" \\"c\\" \\"d\\" \\"e\\"] 2 0))" "(trampoline\\n  make-the-letters [\\"a\\" \\"b\\" \\"c\\" \\"d\\" \\"e\\"] 2 0)" "(clojure.contrib.combinatorics/cartesian-product (repeat 2 [\\"a\\" \\"b\\" \\"c\\" \\"d\\" \\"e\\"]))" "(combinations [\\"a\\" \\"b\\" \\"c\\" \\"d\\" \\"e\\"] 2)" "(n-gram.misc.misc-functions/combinations [\\"a\\" \\"b\\" \\"c\\" \\"d\\" \\"e\\"] 2)" "(n-gram.misc.misc-functions/selections [\\"a\\" \\"b\\" \\"c\\" \\"d\\" \\"e\\"] 2)" "all-chars" "cll-char-pairs" "all-char-pairs" "(reduce str all-char-pairs)" "(reduce \#(str %) all-char-pairs)" "(str (first all-char-pairs))" "all-char-pairs" "(reduce str (first all-char-pairs)))" "(reduce str (first all-char-pairs))" "(reduce \#(reduce str %) all-char-pairs)" "(apply \#(reduce str %) all-char-pairs)" "(maaap \#(reduce str %) all-char-pairs)" "(map \#(reduce str %) all-char-pairs)" "all-char-pairs" "letters" "(update-counts-map all-char-pairs counts-ASCII-2)" "(n-gram.letters.letter-maker/update-counts-map all-char-pairs counts-ASCII-2)" "all-char-counts" "(char 1)" "(str 1)" "(str (char 1)" "(str (char 1))" "all-chars" "all-char-counts" "all-char-pair-counts" "(max-key all-char-pairs)" "(max-key val all-char-pairs)" "(apply max-key val all-char-pairs)" "(alpha-MP-memo (apply max-key val all-char-pairs))" "(alpha-MP-memo (find-all-u-memo initial-alpha))" "(equal initial-alpha 0.0 2)" "(find-all-u-memo 0.0)" "(u-i-MP 0.0 \\"ab\\")" "(vals (F-w2-given-w1-me\\"aaaaaaaaab\\"))" "(vals (F-w2-given-w1-me\\"ab\\"))" "(vals (F-w2-given-w1-memo \\"ab\\"))" "(all-char-pair-counts \\"ab\\")" "(key (first all-char-pair-counts))" "(key (nth all-char-pair-counts 20))" "(key (last all-char-pair-counts))" "(key (butlast all-char-pair-counts))" "(second (key (last all-char-pair-counts)))" "alpha-optimum" "(n-gram.letters.hierarchical-dirichlet/alpha-optimum" "n-gram.letters.hierarchical-dirichlet/alpha-optimum" "n-gram.letters.hierarchical-dirichlet/m-optimum" "all-char-pairs" "(zipmap all-char-pairs (map \#(P (str (second %)) (str (first %)) alpha-optimum m-optimum) all-char-pairs))" "(zipmap all-char-pairs (map \#(n-gram.letters.hierarchical-dirichlet/P (str (second %)) (str (first %)) alpha-optimum m-optimum) all-char-pairs))" "(zipmap all-char-pairs (map \#(n-gram.letters.hierarchical-dirichlet/P (str (second %)) (str (first %)) n-gram.letters.hierarchical-dirichlet/alpha-optimum n-gram.letters.hierarchical-dirichlet/m-optimum) all-char-pairs))" "(defn P ([w2 w1 alpha m] (let [F-w2-w1 (get-count-memo all-char-pair-counts [w2 w1]) F-w1 (get-count-memo all-char-counts [w1]) m-i (find-m-i-memo [w2] m) the-f-w2-w1 (f-w2-w1-memo F-w2-w1 F-w1) lambda-w1 (lambda-memo F-w1 alpha)]\\n                    (+ (* lambda-w1 m-i) (* (- 1 lambda-w1) the-f-w2-w1))))\\n([w2 w1] (let [F-w2-w1 (get-count-memo all-char-pair-counts [w2 w1]) F-w1 (get-count-memo all-char-counts [w1]) m-i (find-m-i-memo [w2] m-optimum) the-f-w2-w1 (f-w2-w1-memo F-w2-w1 F-w1) lambda-w1 (lambda-memo F-w1 alpha-optimum)]\\n                   (+ (* lambda-w1 m-i) (* (- 1 lambda-w1) the-f-w2-w1)))))\\n\\n(def P-memo (memoize P))" "(defn K \\"Returns K (MacKay and Peto Equation 34)\\" [alpha] \\n  (let [count-vals (vals all-char-counts)]\\n  (+ (sum  (map \#(Math/log (/ (+ % alpha) alpha)) count-vals)) (* 0.5 (sum (map \#(/ % (* alpha (+ % alpha))) count-vals))))))\\n\\n(def K-memo \\"Memoized K\\" (memoize K))\\n  \\n(defn F-w2-given-w1  \\"Returns all counts of bigrams with word w2 as the second word\\" [w2] (zipmap (map key all-char-pair-counts)\\n(map \#(if (\= (str (second (key %))) w2) (val %) 0.0) all-char-pair-counts)))\\n\\n(def F-w2-given-w1-memo \\"Memoized F-w2-given-w1\\" (memoize F-w2-given-w1))\\n\\n(defn V-i \\"Returns the number of entries in row 'i' of F-w2-given-w1 that are non-zero\\" [F-w2-w1] (sum (map \#(if (< % 1) 0 1) F-w2-w1)))\\n\\n(def V-i-memo \\"Memoized V-i\\" (memoize V-i))\\n\\n(defn N-f-i \\"Returns the number of contexts w1 such that F-w2-given-w1 is greater than or equal to f\\"\\n  [f F-w2-w1] (sum (map \#(if (>\= f %) 0 1) F-w2-w1)))\\n\\n(def N-f-i-memo \\"Memoized N-f-i\\" (memoize N-f-i))\\n\\n(defn find-F-max \\"Returns the largest F such that N-f-i is greater than zero\\" [F-w2-w1 f] (if (> (N-f-i-memo f F-w2-w1) 0) (find-F-max F-w2-w1 (inc f)) f))\\n\\n(def find-F-max-memo \\"Memoized find-F-max\\" (memoize find-F-max))\\n\\n(defn G-i \\"Returns G-i (MacKay and Peto Equation 32)\\" [i] (let [F-w2-w1 (F-w2-given-w1-memo i) F-vals (vals F-w2-w1) F-min 2 F-max (find-F-max-memo F-vals F-min) f-vector (take (- F-max (dec F-min)) (iterate inc F-min))]\\n                (sum (map \#(/ (N-f-i-memo % F-vals) (- % 1)) f-vector))))\\n\\n(def G-i-memo \\"Memoized G-i\\" (memoize G-i))\\n\\n(defn H-i \\"Returns H-i (MacKay and Peto Equation 33)\\" [i] (let [F-w2-w1 (F-w2-given-w1-memo i) F-vals (vals F-w2-w1) F-min 2 F-max (find-F-max-memo F-vals F-min) f-vector (take (- F-max (dec F-min)) (iterate inc F-min))]\\n                (sum (map \#(/ (N-f-i-memo % F-vals)(Math/pow (- % 1) 2)) f-vector))))\\n\\n(def H-i-memo \\"Memoized H-i\\" (memoize H-i))\\n  \\n(defn u-i-MP \\"Returns the optimal value for u-i\\" [alpha i] (let [F-w2-w1 (vals (F-w2-given-w1-memo i)) V (V-i-memo F-w2-w1) K-alpha (K-memo alpha) G (G-i-memo i) H (H-i-memo i)] (/ (* 2 V) (+ K-alpha (- G) \\n                                                                                                 (java.lang.Math/sqrt (+ (Math/pow (- K-alpha G) 2) (* 4 H V)))))))\\n\\n(def u-i-MP-memo \\"Memoized u-i-MP\\" (memoize u-i-MP))\\n\\n(defn alpha-MP \\"Returns alpha based on the u-i values inputted\\" [u] (sum (vals u)))\\n\\n(def alpha-MP-memo \\"Memoized alpha\\" (memoize alpha-MP))\\n\\n(def initial-alpha 20)\\n\\n(defn find-all-u [alpha] (zipmap (keys all-char-counts) (map \#(u-i-MP-memo alpha %) (keys all-char-counts))))\\n\\n(def find-all-u-memo \\"Memoized find-all-u\\" (memoize find-all-u))\\n\\n(defn find-optimum-u ([] (let [u (find-all-u-memo initial-alpha) alpha (alpha-MP-memo u)] (if (equal initial-alpha alpha 2) u (find-optimum-u alpha))))\\n  ([old-alpha] (let [u (find-all-u-memo old-alpha) alpha (alpha-MP-memo u)] (if (equal old-alpha alpha 2) u (find-optimum-u alpha)))))\\n\\n(def find-optimum-u-memo \\"Memoized find-optimum-u\\" (memoize find-optimum-u))\\n\\n\\n(defn find-all-m [alpha u] (zipmap (keys u) (map \#(/ % alpha) (vals u))))\\n\\n(def find-all-m-memo (memoize find-all-m))\\n\\n(defn lambda [F-w1 alpha] (/ alpha (+ F-w1 alpha)))\\n\\n(def lambda-memo (memoize lambda))\\n\\n(defn f-w2-w1 [F-w2-w1 F-w1] (if (\= 0 F-w2-w1) 0 (/ F-w2-w1 F-w1)))\\n\\n(def f-w2-w1-memo (memoize f-w2-w1))\\n\\n(defn find-m-i [i m] (m i))\\n\\n(def find-m-i-memo (memoize find-m-i))\\n\\n(def u-optimum (find-optimum-u-memo))\\n\\n(def alpha-optimum (alpha-MP-memo u-optimum))\\n\\n(def m-optimum (find-all-m-memo alpha-optimum u-optimum))\\n\\n(defn P ([w2 w1 alpha m] (let [F-w2-w1 (get-count-memo all-char-pair-counts [w2 w1]) F-w1 (get-count-memo all-char-counts [w1]) m-i (find-m-i-memo [w2] m) the-f-w2-w1 (f-w2-w1-memo F-w2-w1 F-w1) lambda-w1 (lambda-memo F-w1 alpha)]\\n                    (+ (* lambda-w1 m-i) (* (- 1 lambda-w1) the-f-w2-w1))))\\n([w2 w1] (let [F-w2-w1 (get-count-memo all-char-pair-counts [w2 w1]) F-w1 (get-count-memo all-char-counts [w1]) m-i (find-m-i-memo [w2] m-optimum) the-f-w2-w1 (f-w2-w1-memo F-w2-w1 F-w1) lambda-w1 (lambda-memo F-w1 alpha-optimum)]\\n                   (+ (* lambda-w1 m-i) (* (- 1 lambda-w1) the-f-w2-w1)))))\\n\\n(def P-memo (memoize P))" "(P \\"a\\" \\"b\\" alpha-optimum m-optimum)" "(get-count-memo all-char-pair-counts [\\"a\\" \\"b\\"])" "(get-count-memo all-char-pair-counts (str \\"a\\" \\"b\\"))" "(defn P ([w2 w1 alpha m] (let [F-w2-w1 (get-count-memo all-char-pair-counts (str w1 w2)) F-w1 (get-count-memo all-char-counts w1) m-i (find-m-i-memo w2 m) the-f-w2-w1 (f-w2-w1-memo F-w2-w1 F-w1) lambda-w1 (lambda-memo F-w1 alpha)]\\n                    (+ (* lambda-w1 m-i) (* (- 1 lambda-w1) the-f-w2-w1))))\\n([w2 w1] (let [F-w2-w1 (get-count-memo all-char-pair-counts (str w2 w1)) F-w1 (get-count-memo all-char-counts w1) m-i (find-m-i-memo w2 m-optimum) the-f-w2-w1 (f-w2-w1-memo F-w2-w1 F-w1) lambda-w1 (lambda-memo F-w1 alpha-optimum)]\\n                   (+ (* lambda-w1 m-i) (* (- 1 lambda-w1) the-f-w2-w1)))))\\n\\n(def P-memo (memoize P))" "(get-count-memo all-char-counts \\"a\\")" "(find-m-i-memo \\"b\\" m-optimum)" "(let [F-w2-w1 (get-count-memo all-char-pair-counts (str w1 w2)) F-w1 (get-count-memo all-char-counts w1) m-i (find-m-i-memo w2 m) the-f-w2-w1 (f-w2-w1-memo F-w2-w1 F-w1) lambda-w1 (lambda-memo F-w1 alpha)]" "(let [F-w2-w1 (get-count-memo all-char-pair-counts (str w1 w2)) F-w1 (get-count-memo all-char-counts w1) m-i (find-m-i-memo w2 m) the-f-w2-w1 (f-w2-w1-memo F-w2-w1 F-w1) lambda-w1 (lambda-memo F-w1 alpha)])" "(let [F-w2-w1 (get-count-memo all-char-pair-counts (str \\"a\\" \\"b\\")) F-w1 (get-count-memo all-char-counts \\"a\\") m-i (find-m-i-memo \\"b\\" m-optimum) the-f-w2-w1 (f-w2-w1-memo F-w2-w1 F-w1) lambda-w1 (lambda-memo F-w1 alpha-optimum)])" "F-w2-w1 (get-count-memo all-char-pair-counts (str \\"a\\" \\"b\\"))" "(get-count-memo all-char-counts \\"a\\")" "(find-m-i-memo \\"b\\" m-optimum)" "(f-w2-w1-memo 4 389)" "(lambda-memo 389\\n             alpha-optimum)" "(+ (* 0.016316422360590423 0.01260724026522865) (* (- 1 0.016316422360590423) (/ 4 389)))" "(P \\"a\\" \\"b\\" alpha-optimum m-optimum)" "(P \\" \\" \\" \\" alpha-optimum m-optimum)" "(P \\" . \\n\\" \\" \\" alpha-optimum m-optimum)" "(P \\"5\\" \\"b\\" alpha-optimum m-optimum)" "(P \\"y\\" \\"q\\" alpha-optimum m-optimum)" "(map \#(P (str (second %)) (str (first %)) alpha-optimum m-optimum) all-char-pairs))" "(zipmap [\\"a\\" \\"b\\" \\"c\\"] [1 2 3])" "all-char-pairs" "(count (map \#(P (str (second %)) (str (first %)) alpha-optimum m-optimum) all-char-pairs)))" "(count (map \#(P (str (second %)) (str (first %)) alpha-optimum m-optimum) all-char-pairs))" "(count all-char-pairs)" "map-of-pairs-probs" "(predict-next-letter \\"lion\\" 10)" "(next-letter \\"lion\\" map-of-pairs-probs)" "(find-letter-pair \\"lion\\" map-of-pairs-probs)" "(map \#(if (\= (str(first (key %))) \\"n\\")\\n                                           (val %) 0.0) all-char-pair-counts)" "(find-letter-pair \\"lion\\" map-of-pairs-probs)" "map-of-pairs-probs" "(str (first (key (first map-of-pairs-probs))))" "(find-letter-pair \\"n\\" map-of-pairs-probs)" "(str (last \\"lion\\"))" "(predict-next-letter \\"lion\\" 10)" "(next-letter \\"lion\\" 10 map-of-pairs-probs)" "(next-letter \\"lion\\" map-of-pairs-probs)" "(key (apply max-key val (find-letter-pair-memo (str (last \\"lion\\")) map-of-pairs-probs)))" "(key (apply max-key val (find-letter-trio-memo (str (butlast \\"lion\\")) \\n                                                                  (str (last \\"lion\\")) map-of-pairs-probs)))" "(find-letter-trio (str (butlast \\"lion\\")) (str (last \\"lion\\")) map-of-pairs-probs)" "(str (first (key (first map-of-pairs-probs))))" "formattedText" "n-gram.words.file-reader/formattedText" "(key (apply max-key val (find-letter-trio-memo (str (butlast \\"lion\\")) \\n                                                                  (str (last \\"lion\\")) map-of-pairs-probs)))" "map-of-pairs-probs" "(predict-next-letter \\"lion\\" 10)" "(next-letter \\"n\\" map-of-pairs-probs)" "(next-letter \\"on\\" map-of-pairs-probs)" "(next-letter \\"nd\\" map-of-pairs-probs)" "(next-letter \\"d \\" map-of-pairs-probs)" "(predict-next-letter \\"lion\\" 10)" "(loop-next-letters \\"on\\" 10 map-of-pairs-probs)"]
eclipse.preferences.version=1
